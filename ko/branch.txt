== 나뭇가지 (branch) 마법 ==

Git의 죽이는 기능들 중에는 즉석으로 브랜칭 및 병합이 가능하다는 것입니다.

*예시문제*: 외부적인 요소들은 불가피하게 당신이 하던 일은 그만두게 합니다. 예를 들어, 치명적인 버그가
이미 배포된 버전에서 경고없이 퍼저나가게 생겼습니다. 프로그램에 새로 넣어야 할
기능이 있는데 데드라인은 가까워져 옵니다. 당신이 도움을 요청하고자 했던 개발자는 퇴사할려고 하니 도움을 요청할 수도 없고요. 시간이 촉박한 만큼 하던 일을 멈추고 버그를 고치는 데에 올인을 해야겠지요.

위와 같이 하던 일을 멈추는 것은 일의 생산성을 치명적으로 떨어트립니다. 특히나 지금까지 하던 일과 정 상관없는 부분의 프로그램을 건들어야 할 때 말이죠. 이럴 때, 중앙 버전 관리 시스템을 사용하는 경우엔 작동이 되는 버그없는 프로그램을 다시 받아야 합니다. 분산 관리 시스템일 경우에는 원하는 버전만 로컬 컴퓨터로 받아내면 되죠.

하지만 클로닝은 작업 중인 디렉토리 포함 그 디렉토리의 히스토리를 어느 선까지는 같이 다운로드 받게 합니다. Git은 최대한 효율성있게 시스템이 디자인되어 있지만, 클로닝 명령어를 쓴다면 프로젝트 파일들이 (비효율적으로) 현재 작업 중인 디렉토리에 전부 다시 생성될 것입니다.

*해답*: Git은 이런 상황에서 좀 더 빠르고 공간적으로 효율성있게 클로닝을 할 수 있는 명령어를 가지고 있습니다: *git branch*

이런 환상적인 명령어를 이용하여 디렉토리에 있는 파일들은 탈바꿈을 감행해 이 버전과 저 버전을 넘나들 수 있습니다. 이 변형기법은 버전 사이를 넘나드는 것 외에도 더 많은 것을 할 수 있습니다. 당신의 파일들은 전 버전에서 실험할 있는 임시버전, 개발버전, 친구들이 보유하고 있는 버전 등으로 변형할 수 있습니다.

=== 일하는 척 하기 버튼 ===

버튼 하나만 누르면 ("일하는 척 하기 버튼") 게임화면이 최소화되고 엑셀파일이 화면상에 나타나는 기능을 보신 적이 있을겁니다. 이 기능을 활용하면 직장상사의 눈을 속이고 일하던 척 할 수 있지요?

아무 디렉토리에서:

 $ echo "I'm smarter than my boss" > myfile.txt # 난 내 상사보다 똑똑하다
 $ git init
 $ git add .
 $ git commit -m "Initial commit"

우리는 "난 내 상사보다 똑똑하다"라는 내용을 가진 텍스트파일을 Git 저장소에 만들었습니다. 그리고:

 $ git checkout -b boss  # 이 명령어를 사용한 후엔 아무것도 바뀌지 않은 것처럼 보일겁니다.
 $ echo "My boss is smarter than me" > myfile.txt # 상사는 나보다 똑똑합니다
 $ git commit -a -m "Another commit"

겉으로 보기에는 그 텍스트파일을 새로운 (맘에 들지않는) 문장으로 덮어씌우고  commit을 한 것처럼 보일겁니다. 그러나 그건 착각입니다. 다음 명령어를 입력해보세요:
 
 $ git checkout master  # 처음 버전으로 돌아가기

자! 그럼 처음 생성했던 텍스트파일이 돌아왔을 겁니다. 만약에 그 상사가 이 사실을 알아채고 당신의 디렉토리를 살펴본다고 할 때는:
 
 $ git checkout boss  # 아까 두 번째로 만들어놓은 "상사는 나보다 똑똑합니다"라는 메세지를 담은 myfile.txt 파일로 돌아갑니다.

이런 식으로 두 가지 다른버전의 파일 사이를 오갈 수 있습니다. 그리고 각각 따로 commit을 할 수 있지요.
 
=== 힘든 작업 ===

[[나뭇가지 (branch)]]
당신이 어떤 작업을하고 있다고 가정합니다. 작업 도중에 세 버전 전으로 돌아가서 새로운 print 라인을 넣고 테스팅 해보고 싶다는 생각이 들었습니다. 그럴 때엔:

 $ git commit -a
 $ git checkout HEAD~3

이제 테스팅하고 싶었던 파일에 더하고 싶은 것을 걱정없이 마구 넣어도 됩니다. 이 미친 짓(?)을 Commit 해놓을 수도 있습니다. 작업이 다 끝났다면,
 
 $ git checkout master

를 사용해 아까 미친 짓을 하기 전의 작업상태로 돌아올 수 있습니다. Commit하지 않았던 작업들이 같이 딸려 왔다는 것을 확인 (조심!)할 수 있을 겁니다.
 
아까 그 임시작업 (미친 짓)을 세이브하고 싶다면 어떻게 해야할까요? 쉽습니다:
 
 $ git checkout -b dirty

를 실행하여 그 나뭇가지 (branch) 에서 마스터 나뭇가지로 돌아오기 전에 commit을 하면 됩니다. 그런 후 다시 미친 짓을 할 때의 상태로 돌아가고 싶다면:

 $ git checkout dirty

우리는 이 체크아웃이라는 명령어를 전에도 설명했었죠. 여기서는 이 명령어가 어떻게 예전 버전들을 불러오는 지 살펴볼 수 있었습니다: 파일을 원하는 버전으로 돌아가게 할 수 있으나, master 나뭇가지를 우선 벗어나야 하지요. 벗어난 후의 commit은 master 나뭇가지와는 다른 길을 걷게 될 것입니다. 그 길을 나중에 이름도 지어줄 수 있지요.
 
다시 말하면, 예전 상태 (state)에서 벗어나면 Git은 자동으로 이름이 (아직) 붙여지지 않은 새로운 나뭇가지로 이동시켜 줍니다. 이 나뭇가지는 *git checkout -b*로 이름을 바꿔 저장해줄 수 있죠.

=== 빠른 해결책 ===

작업 중에 갑자기 하던 일을 멈추고 '1b6d...'commit에 있는 버그를 고치라고 부탁을 받았다고 생각해 봅시다:

 $ git commit -a
 $ git checkout -b fixes 1b6d

버그를 다 고친 후에:
 
 $ git commit -a -m "Bug fixed"
 $ git checkout master

이제 아까 잠시 중단했던 작업으로 돌아갈 수 있습니다. 버그가 고쳐진 파일도 병합해올 수 있죠:

 $ git merge fixes

=== 병합 (Merging) ===

With some version control systems, creating branches is easy but merging them
back together is tough. With Git, merging is so trivial that you might be
unaware of it happening.

We actually encountered merging long ago. The *pull* command in fact 'fetches'
commits and then merges them into your current branch. If you have no local
changes, then the merge is a 'fast forward', a degenerate case akin to fetching
the latest version in a centralized version control system. But if you do have
local changes, Git will automatically merge, and report any conflicts.

Ordinarily, a commit has exactly one 'parent commit', namely, the previous
commit. Merging branches together produces a commit with at least two parents.
This begs the question: what commit does `HEAD~10` really refer to? A commit
could have multiple parents, so which one do we follow?

It turns out this notation chooses the first parent every time. This is
desirable because the current branch becomes the first parent during a merge;
frequently you're only concerned with the changes you made in the current
branch, as opposed to changes merged in from other branches.

You can refer to a specific parent with a caret. For example, to show
the logs from the second parent:

 $ git log HEAD^2

You may omit the number for the first parent. For example, to show the
differences with the first parent:

 $ git diff HEAD^

You can combine this notation with other types. For example:

 $ git checkout 1b6d^^2~10 -b ancient

starts a new branch ``ancient'' representing the state 10 commits back from the
second parent of the first parent of the commit starting with 1b6d.

=== Uninterrupted Workflow ===

Often in hardware projects, the second step of a plan must await the completion of the first step. A car undergoing repairs might sit idly in a garage until a particular part arrives from the factory. A prototype might wait for a chip to be fabricated before construction can continue.

Software projects can be similar. The second part of a new feature may have to
wait until the first part has been released and tested. Some projects require
your code to be reviewed before accepting it, so you might wait until the first
part is approved before starting the second part.

Thanks to painless branching and merging, we can bend the rules and work on
Part II before Part I is officially ready. Suppose you have committed Part I
and sent it for review. Let's say you're in the `master` branch. Then branch
off:

 $ git checkout -b part2

Next, work on Part II, committing your changes along the way. To err is human,
and often you'll want to go back and fix something in Part I.
If you're lucky, or very good, you can skip these lines.

 $ git checkout master  # Go back to Part I.
 $ fix_problem
 $ git commit -a        # Commit the fixes.
 $ git checkout part2   # Go back to Part II.
 $ git merge master     # Merge in those fixes.

Eventually, Part I is approved:

 $ git checkout master  # Go back to Part I.
 $ submit files         # Release to the world!
 $ git merge part2      # Merge in Part II.
 $ git branch -d part2  # Delete "part2" branch.

Now you're in the `master` branch again, with Part II in the working directory.

It's easy to extend this trick for any number of parts. It's also easy to
branch off retroactively: suppose you belatedly realize you should have created
a branch 7 commits ago. Then type:

 $ git branch -m master part2  # Rename "master" branch to "part2".
 $ git branch master HEAD~7    # Create new "master", 7 commits upstream.

The `master` branch now contains just Part I, and the `part2` branch contains
the rest. We are in the latter branch; we created `master` without switching to
it, because we want to continue work on `part2`. This is unusual. Until now,
we've been switching to branches immediately after creation, as in:

 $ git checkout HEAD~7 -b master  # Create a branch, and switch to it.

=== Reorganizing a Medley ===

Perhaps you like to work on all aspects of a project in the same branch. You want to keep works-in-progress to yourself and want others to see your commits only when they have been neatly organized. Start a couple of branches:

  $ git branch sanitized    # Create a branch for sanitized commits.
  $ git checkout -b medley  # Create and switch to a branch to work in.

Next, work on anything: fix bugs, add features, add temporary code, and so forth, committing often along the way. Then:

  $ git checkout sanitized
  $ git cherry-pick medley^^

applies the grandparent of the head commit of the ``medley'' branch to the ``sanitized'' branch. With appropriate cherry-picks you can construct a branch that contains only permanent code, and has related commits grouped together.

=== Managing Branches ===

List all branches by typing:

 $ git branch

By default, you start in a branch named ``master''. Some advocate leaving the
``master'' branch untouched and creating new branches for your own edits.

The *-d* and *-m* options allow you to delete and move (rename) branches.
See *git help branch*.

The ``master'' branch is a useful custom. Others may assume that your
repository has a branch with this name, and that it contains the official
version of your project. Although you can rename or obliterate the ``master''
branch, you might as well respect this convention.

=== Temporary Branches ===

After a while you may realize you are creating short-lived branches
frequently for similar reasons: every other branch merely serves to
save the current state so you can briefly hop back to an older state to
fix a high-priority bug or something.

It's analogous to changing the TV channel temporarily to see what else is on.
But instead of pushing a couple of buttons, you have to create, check out,
merge, and delete temporary branches. Luckily, Git has a shortcut that is as
convenient as a TV remote control:

 $ git stash

This saves the current state in a temporary location (a 'stash') and
restores the previous state. Your working directory appears exactly as it was
before you started editing, and you can fix bugs, pull in upstream changes, and
so on. When you want to go back to the stashed state, type:

 $ git stash apply  # You may need to resolve some conflicts.

You can have multiple stashes, and manipulate them in various ways. See
*git help stash*. As you may have guessed, Git maintains branches behind the scenes to perform this magic trick.

=== Work How You Want ===

You might wonder if branches are worth the bother. After all, clones are almost
as fast, and you can switch between them with *cd* instead of esoteric Git
commands.

Consider web browsers. Why support multiple tabs as well as multiple windows?
Because allowing both accommodates a wide variety of styles. Some users like to
keep only one browser window open, and use tabs for multiple webpages. Others
might insist on the other extreme: multiple windows with no tabs anywhere.
Others still prefer something in between.

Branching is like tabs for your working directory, and cloning is like opening
a new browser window. These operations are fast and local, so why not
experiment to find the combination that best suits you? Git lets you work
exactly how you want.
