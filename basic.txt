== Basic Tricks ==

Rather than diving into a sea of Git commands, use these elementary examples to get your feet wet. Despite their simplicity, each of them are useful in real life.

=== Saving State ===

When I'm about to attempt something drastic I like to save the current state, so I can go back and try again should things go awry.

Take a snapshot of all files in the current directory with:

 $ git init
 $ git add .
 $ git commit -m "My first backup"

The above sequence of commands should be memorized, or placed in a script, as they will be reused frequently.

Then if something goes wrong, run:

 $ git reset --hard

to go back to where you were. To save the state again:

 $ git commit -a -m "Another backup"

==== Add, Delete, Rename ====

The above will only keep track of the files that were present when you first ran *git add*. If you add new files or subdirectories, you'll have to tell Git:

 $ git add NEWFILES...

Similarly, if you want Git to forget about certain files, maybe because you've deleted them

 $ git rm OLDFILES...

Renaming a file is the same as removing the old name and adding the new name. There's also the shortcut *git mv* which has the same syntax as the *mv* command. For example:

 $ git mv OLDFILE NEWFILE

=== Advanced Undo/Redo ===

Sometimes you just want to go back and forget about every change past a certain point because they're all wrong.

Then

 $ git log

shows you a list of recent commits, and their SHA1 hashes. Next, type

 $ git reset --hard SHA1_HASH

to restore the state to a given commit and erase all newer commits from the record permanently.

Other times you want to hop to an old state briefly. In this case, type:

 $ git checkout SHA1_HASH

This takes you back in time, while preserving newer commits. However, like time travel in a science-fiction movie, if you now edit and commit, you will be in an alternate reality, because your actions are different to what they were the first time around.

This alternate reality is called a ''branch'', and <<branch,we'll have more to say about this later>>. For now, just remember that

 $ git checkout master

will take you back to the present.

Uncommitted changes travel in time with you when you run checkout.

To take the computer game analogy again:

- *`git reset \--hard`*: load an old save and delete all saved games newer than the one just loaded.

- *`git checkout`*: load an old game, but if you play on, the game state will deviate from the newer saves you made the first time around. Any saved games you make now will end up in a separate branch representing the alternate reality you have entered. <<branch,We deal with this later>>.

You can choose only to restore particular files and subdirectories by appending them after the command.

Don't like cutting and pasting hashes? Then use:

 $ git checkout "@{10 minutes ago}" .

Other time specifications work too. For example, you can ask for the 5th-last saved state:

 $ git checkout "@{5}" .

==== Reverting ====

In a court of law, events can be stricken from the record. Likewise, you can pick specific commits to undo.

 $ git commit -a
 $ git revert SHA1_HASH

will undo just the commit with the given hash. Running *git log* reveals the revert is recorded as new commit.

=== Dowloading Files ===

If a project uses Git to manage its files, you can get a copy with:

 $ git clone git://server/path/to/files

For example, to get all the files I used to create this site:

 $ git clone git://git.or.cz/gitmagic.git

We'll have a lot more to say about the *clone* command later.

=== The Bleeding Edge ===

If a project uses Git to manage its files, and you've already downloaded a copy using *git clone*, you can upgrade to the latest version with:

 $ git pull

=== Instant Publishing ===

Let's say you've written a script you'd like to share with others. You could just tell them to download from your computer, but if they do so while you're improving the script or making experimental changes, they could wind up in trouble.  Of course, this is why release cycles exist. Code is written, and at certain points in time, when it's suitable for others, it gets released.

To do this with Git, in the directory where your script resides:

 $ git init
 $ git add .
 $ git commit -m "First release"

Then tell your users to type

 $ git clone your.computer:/path/to/script

to download your script. This assumes they have ssh access. If not, run *git daemon* and tell your users to type

 $ git clone git://your.computer/path/to/script

From now on, every time your script is ready for release, type:

 $ git commit -a -m "Next release"

and your users can upgrade their version by changing to the directory containing your script and typing.

 $ git pull

Your users will never end up with a version of your script you don't want them to see. Obviously this trick works for anything, not just scripts.

=== What Have I Done? ===

Find out what changes you've made since the last commit with:

 $ git diff

Or since yesterday:

 $ git diff "@{yesterday}"

Or between a particular version and 2 versions ago:

 $ git diff SHA1_HASH "@{2}"
