= Basic Tricks =

Rather than diving into a sea of Git commands, use these elementary examples to get your feet wet. Despite their simplicity, each of them are useful in real life.

== Instant Backup ==

When I'm about to attempt something drastic I like to save the current state, so I can go back and try again should things go awry.

 $ git-init
 $ git-add .
 $ git-commit -m "my first backup"

to take a snapshot of all files in the current directory.
Then if something goes wrong type

 $ git-checkout HEAD .

to go back to where you were. To save the state again, you can type

 $ git-commit -a -m "another backup"

=== Adding, Deleting, Renaming Files ===

The above will only keep track of the files that were present when you first ran <tt>git-add</tt>. If you add new files to the directory, you'll have to tell Git:

 $ git-add NEWFILES...

Similarly, if you want Git to forget about certain files, maybe because you've deleted them

 $ git-rm OLDFILES...

Renaming a file is the same as removing the old name and adding the new name. There's also the shortcut <tt>git-mv</tt> which has the same syntax as the <tt>mv</tt> command. For example:

 $ git-mv OLDFILE NEWFILE

== Advanced Undo/Redo ==

Typing <tt>git-log</tt> shows you a list of recent commits, and their SHA1 hashes. Then typing:

 $ git-checkout SHA1_HASH .

will load the previous state with the given hash.
Don't like working with hashes? Then use:

 $ git-checkout "@{10 minutes ago}" .

Other time specifications work too. Or you can ask for the 5th-last saved state:

 $ git-checkout "@{5}" .

In some circumstances, it is preferable to type:

 $ git-commit -a
 $ git-revert SHA1_HASH

This appears to have the same affect, but <tt>git-log</tt> reveals that the fact that you loaded an old saved state has been recorded as new commit. In other words, you can have Git track you when you undo and redo.

Lastly, other times you might want:

 $ git-reset --hard SHA1_HASH

which restores the state to a given commit but also erases all newer commits from the record permanently.

To take the computer game analogy again, <tt>git-checkout</tt> is like loading a game, <tt>git-revert</tt> is like loading a game and recording this fact as another saved game, and <tt>git-reset --hard</tt> is like loading an old save and deleting all saved games newer than the one just loaded.

== Sync Computers ==

This is the reason I first used Git. I can tolerate making tarballs or using <tt>rsync</tt> for backups. The problem was sometimes I'd edit on my laptop, other times on my desktop, and they may not have talked to each other in between.

Initialize a Git repository and commit your files as above on one machine. Then on the other:

 $ git-clone git+ssh://other.computer/directory

to get a second copy. From now on,

 $ git-commit -a
 $ git-pull git+ssh://other.computer/directory

will pull in the state of the files on the other computer into the one you're working on. If you've recently made conflicting edits in the same file, Git will let you know and you should resolve them with another edit and commit.

If you have not committed any changes on the other computer, you may type

 $ git-push git+ssh://other.computer/directory

to push the current state to the other computer. Next time you're there, run git-reset --hard or git-checkout HEAD . to update the files.

That Git does not do the last step automatically is good in case you were in the middle of some uncommitted changes.
