== Приложение А: Недостатки Git ==

Есть некоторые проблемы Git, которые я спрятал под сукно. Некоторые из них можно легко решить с помощью скриптов и хуков, некоторые требуют реорганизации или пересмотра проекта, а несколько оставшихся неприятностей придётся потерпеть. А еще лучше — взяться за них и решить!

=== Слабости SHA1 ===

Со временем криптографы обнаруживают всё больше и больше слабостей в SHA1. Уже сейчас обнаружение коллизий хешей осуществимо для хорошо финансируемой организации. Спустя годы, возможно, даже типичный ПК будет иметь достаточную вычислительную мощность, чтобы незаметно испортить Git хранилище.

Надеюсь Git перейдёт на лучшую хеш-функцию прежде чем дальнейшие исследования уничтожат SHA1.

=== Microsoft Windows ===

Git на Microsoft Windows может быть громоздким:

- http://cygwin.com/[Cygwin], Linux-подобная среда для Windows, содержит http://cygwin.com/packages/git/[порт Git на Windows].

- http://code.google.com/p/msysgit/[Git на MSys] вариант, требующий минимальной рантайм поддержки, хотя для нескольких комманд, нужна доработка.

=== Несвязанные файлы ===

Если ваш проект очень велик и содержит много не связанных файлов, которые постоянно изменяются, Git могжет оказаться в невыгодном положении по сравнению с другими системами, поскольку отдельные файлы не отслеживаются. Git отслеживает изменения всего проекта, что обычно бывает выгодным.

Решение — разбить проект на части, каждая из которых состоит из связанных файлов. Используйте *git submodule* если вы все же хотите держать все в одном хранилище.

=== Кто и что редактировал ? ===

Некоторые системы контроля версий вынуждают вас явным образом пометить файл перед редактированием. Хотя такой подход особенно раздражает, когда подразумевает работу с центральным сервером, однако он имеет два преимущества:

  1. Diff'ы быстры, т.к. нужно проверить только отмеченные файлы.

  2. Можно обнаружить, кто еще работает с этим файлом, спросив центральный сервер, кто отметил его для редактирования.

С помощью соответствующих скриптов, вы можете добиться того же с Git. Это требует сотрудничества со стороны другого программиста, который должен запускать определённый скрипт при редактировании файла.

=== История файла ===

Поскольку Git записывает изменения всего проекта, восстановление историю одного файла требует больше работы, чем в системах контроля версиями, следящими за отдельными файлами.

Потери как правило незначительны, и это неплохая цена за то, что другие операции невероятно эффективны. Например, git checkout быстрее, чем cp -a, а дельта всего проекта сжимается лучше, чем коллекция по-файловых дельт.

=== Начальное Клонирование ===

Создание клона хранилища дороже обычного чекаута в других системах управления версиями, особенно при длинной истории.

Первоначальная цена окупается в долгосрочной перспективе, т.к. большинство последующих операций будут быстрыми и автономными. Однако в некоторых ситуациях может быть предпочтительным создание мелких клонов с опцией --depth. Это намного быстрее, но в полученный клон имеет урезанную функциональность.

=== Изменчивые Проекты ===

Git была написан, чтобы быть быстрым по отношению к небольшим изменениям. Люди делают небольшие исправления от версии к версии. Однострочные исправление здесь, новые функции там, исправленные комментарии, и так далее. Но если ваши файлы, радикально отличаются в следующей ревизии, то на каждой фиксации, ваша история обязательно увеличивается на размер всего вашего проекта.

Не существует системы управления версиями, которая может решить эту проблему, но пользователи Git пострадают больше, поскольку клонируется вся история.

Причины, почему эти изменения бывают настолько велики, должны быть изучены. Возможно, формат файла должен быть изменен. Малые изменения должны быть причиной малых изменений в самих файлах.

Или, возможно, то, что вам было нужно, это базы данных или система резервного копирования или архивы, а не система контроля версий. Например, контроль версий может быть плохо приспособлен для управления фотографиями периодически получаемых с веб-камеры.

Если файлы действительно должны постоянно изменяться, и они действительно должно быть версионироваться, возможность использовать Git централизованным образом. Можно создать мелкой клоны, с небольшой или без истории проекта. Конечно, многие инструменты Git будут недоступны, и исправления должны быть представлены в виде патчей. Вероятно, это штраф, потому как неясно, почему кто-то хочет вести историю дико неустойчиво файлов.

Другим примером является проект, зависимый от прошивки, которая принимает форму огромного бинарного файла. История этой микропрограммы неинтересна для пользователей, и обновления сжимаются плохо, так версии микропрограммы могут излишне увеличить размера хранилища.

В этом случае исходный код должен храниться в хранилище Git, а бинарные файлы - отдельно. Чтобы сделать жизнь проще, можно было бы распространять скрипт, который используется Git чтобы клонировать код и Rsync или мелкий клон Git для прошивки.

=== Глобальный счетчик ===

Некоторые централизованные системы контроля версий, используют положительные числа, которые возрастают, когда происходит новый коммит. Git идентифицирует изменения их хэшем, который лучше во многих обстоятельствах.

Но некоторым люди нравится эти целые вокруг. К счастью, легко написать сценарии, чтобы при каждом обновлении центральное хранилище Git увеличивало целое число, возможно, в теге, и связывает его с хэшем последним коммитом.

Каждай клон может поддерживать такой счетчик, но это, вероятно, будет бесполезным, поскольку только центральное хранилище имеет значение для всех.

=== Пустые подкаталоги ===

Пустые подкаталоги не могут быть отслежены. Создайте пустой файл, чтобы обойти эту проблему.

В этом виноват не дизайн Git, а его текущая реализация. Если повезет и пользователи Git уделят больше внимания этой функции, возможно она будет реализована.

=== Первоначальный коммит ===

Обычный ученый в области информатики считает от 0, а не от 1. К сожалению, Git с его коммитами не присоединиться к этой конвенции. Многие команды плохо работают до первого коммита. Кроме того, некоторые частные случаи должны быть обработаны специально, такие, как rebase веток с различными начальными коммитами.

Git'у желательно определение нулевого совершения: как только будет построено хранилище, HEAD будет установлен в строку, состоящую из 20 нулевых байтов. Эта специальный коммит представляет собой пустое дерево, без родителей, предшествовавшие всему в хранилище Git.

Затем запустить *git log*, например, будет показывать пользователю, что коммиты еще не были сделаны вместо выхода с фатальной ошибкой. Аналогично для других инструментов.

Каждая первоначальная фиксация - неявный потомок этого нулевого коммита. Например, несвязанный с какой-либо веткой rebase в целом будет привита на эту цель. В настоящее время применяются все, кроме первоначального коммита, в результате чего получается конфликт слияния. Один из способов заключается в использовании `git checkout` после `git commit -C` первоначального коммита, тогда rebase пройдет нормально.

К сожалению, в худшем случае, если несколько ветвей с различными начальными коммитами сливаются, то rebase результата требует значительного ручного вмешательства.
