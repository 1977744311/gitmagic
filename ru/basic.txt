== Базовые операции ==

Прежде чем погружаться в дебри многочисленных Git команд, попробуйте воспользоваться этими простыми примерами, чтобы немного освоиться. Несмотря на свою простоту, каждая из них является полезной.

Действительно, в первые месяцы использования Git я не выходил за рамки материала изложенного в этой главе.

=== Сохранение состояния ===

Выполняете опасную операцию? Перед тем, как сделать это, создайте снимок всех файлов в текущей директории с помощью команд:

 $ git init 
 $ git add .  
 $ git commit -m "Мой первый бекап"
 
Теперь, если ваши новые правки все испортили, запустите:

 $ git reset --hard

чтобы вернуться к исходному состоянию. Чтобы вновь сохраниться выполните:

 $ git commit -a -m "Другой бекап"

==== Добавление, Удаление, Переименование ====

Приведенный  выше пример будет отслеживать файлы, которые вы добавили когда впервые запустили *git add*. Если вы хотите добавить новые файлы или поддиректории, вам придется сказать Git:

 $ git add НОВЫЕ_ФАЙЛЫ...

Аналогично, если вы хотите чтобы Git забыл о некоторых файлах, может быть, потому, что вы удалите их:

 $ git rm СТАРЫЕ_ФАЙЛЫ...

Переименование файла это то же, что и удаление старого имени и добавления нового. Для этого есть *git mv*, который имеет тот же синтаксис, что и команда *mv*. Например:

 $ git mv OLDFILE NEWFILE

=== Расширенная отмена/Восстановление ===

Иногда вы просто хотите вернуться к определенной точке и забыть все изменения, потому что все они были неправильными. В таком случае:

 $ git log

покажет вам список последних изменений (коммитов, прим. пер.), и их SHA1 хеши. Далее введите:

 $ git reset --hard SHA1_HASH

для восстановления состояния до указанного коммита и удаления всех последующих коммитов безвозвратно.

Возможно, в другой раз вы захотите быстро вернуться к старому состоянию. В этом случае наберите:

 $ git checkout SHA1_HASH

Это перенесет вас назад во времени, до тех пор пока вы не сделаете новые коммиты. Как и в фантастических фильмах о путешествиях во времени, если вы редактируете и коммитите код, вы будете находиться в альтернативной реальности, потому что ваши действия отличаются от тех, что вы делали до этого.

Эта альтернативная реальность называется 'бранч' и 
<<branch,мы поговорим об этом больше чуть позже>>. А сейчас просто запомните:

 $ git checkout master

вернёт вас обратно в настоящее. Кроме того, чтобы не получать предупреждений от Git, всегда делайте коммит или сброс ваших изменений до запуска checkout.

Еще раз воспользуемся терминологией компьютерных игр:

- *`git reset --hard`*: загружает ранее сохраненную игру и удаляет все версии, сохраненные после только что загруженной.

- *`git checkout`*: загружает старую игру, но если вы продолжаете играть, состояние игры будет отличаться от более новых сохранок, которые вы сделали в первый раз. Любая игра, которую вы теперь сохраняете, попадает в отдельный бранч, прадставляющий альтенативную реальность, в которую вы вошли.
<<branch,как мы договорились, о бранчах поговорим позже>>

Вы можете выбрать для восстановления только определенные файлы и поддиректории путём добавления их после команды:

 $ git checkout SHA1_HASH some.file another.file

Будьте внимательны, такая форма *checkout* (чекаута) может незаметно перезаписать файлы. Чтобы избежать неприятных неожиданностей, выполняйте коммит до запуска "чекаут", особенно если вы впервые пробуете Git. Вообще, если вы не уверены в какой-либо операции, будь то команда Git или нет, сперва выполните *git commit -a*.

Не любите копировать и вставлять хеши? Используйте:

 $ git checkout :/"Мой первый б"

для перехода на коммит, который начинается с приведенной строки.

Можно также запросить 5-е последнее  сохраненное состояние:

 $ git checkout master~5

==== Возвраты ====

В зале суда в протокол могут вноситься изменения прямо во время слушания. Подобным образом и вы можете выбирать коммиты для возврата.

 $ git commit -a
 $ git revert SHA1_HASH

отменит  текущий коммит с учетом выбранного хеша. Запущенный *git log* показывает, что изменение записано в качестве нового коммита.

=== Скачивание файлов ===

Получить копию проекта под управлением Git можно набрав:

 $ git clone git://server/path/to/files

Например, чтобы получить все файлы, я создавал такой сайт:

 $ git clone git://git.or.cz/gitmagic.git

Мы поговорим больше о команде *clone* позже.

=== Сглаживание углов ===

Если вы уже загрузили копию проекта с помощью *git clone*, вы можете обновить его до последней версии используя:

 $ git pull

=== Публичный доступ ===

Предположим, вы написали скрипт которым хотите поделиться с другими. Можно просто позволить всем загружать его с вашего компьютера, но, если они будут делать это в то время, как вы дорабатываете его или добавляете экспериментальную функциональность, у них могут возникнуть проблемы. Конечно, это одна из причин существования цикла разработки. Разработчики могут долго работать над проектом, но открывать доступ к коду следует только после того, как код приведен в приличный вид.

Чтобы сделать это с помощью Git, выполните в директории, где лежит ваш скрипт:

 $ git init
 $ git add .
 $ git commit -m "Первый релиз"

Затем скажите вашим пользователям запустить:

 $ git clone ваш.компьютер:/path/to/script

для того чтобы загрузить ваш скрипт. Это подразумевает что у вас есть доступ по ssh. Если нет, запустите *git daemon* и скажите пользователям использовать для запуска:

 $ git clone git://ваш.компьютер/path/to/script

Теперь, всякий раз когда ваш скрипт готов к релизу, выполняйте:

 $ git commit -a -m "Следующий релиз"

и ваши пользователи смогут обновить свои версии, перейдя в директорию, содержащую ваш скрипт, и, набрав:

 $ git pull

Ваши пользователи никогда не попадут на версии скрипта, доступ к которым вы скрываете. Безусловно, что этот трюк работает для всего, не только в случаях со скриптами.

=== Что я наделал? ===

Выяснить, какие изменения вы сделали со времени последнего коммита:

 $ git diff

Или со вчерашнего дня:

 $ git diff "@{yesterday}"

Или между определенной версией и 2-мя предыдущими версиями.

 $ git diff SHA1_HASH "master~2"

В каждом случае на выходе будет патч, который может быть применён с помощью *git apply*.

Попробуйте также:

 $ git whatchanged --since="2 weeks ago"

Часто я смотрю историю при помощи http://sourceforge.net/projects/qgit[qgit] вместо стандартного способа,
из-за приятного фотогеничного интерфейса, или с помощью http://jonas.nitro.dk/tig[tig] с текстовым интерфейсом,
который хорошо работает при медленном соединении. В качестве альтернативы, можно проинсталировать веб-сервер,
введя *git instaweb*, и запустить любой веб-браузер.

=== Упражнение ===

Пусть A, B, C, D четыре успешных коммита, где В - то же, что и A, но с несколькими удаленными файлами. Мы хотим вернуть файлы в D, но не в B. Как это можно сделать?

Существует как минимум три решения. Предположим, что мы находимся на D.

  1. Разница между A и B - удаление файлов.
  Мы можем создать патч, отражающий эти изменения, и применить его:
  
   $ git diff B A | git apply
  
  2. Поскольку мы сохранили файлы  обратно в A, мы можем получить их обратно:
  
   $ git checkout A FILES...
  
  3. Мы можем рассматривать переход от A до B в качестве изменений, которые мы хотим отменить:
  
   $ git revert B

Какой способ лучший?
Тот, который вам больше нравится. С Git легко сделать все, что вы хотите, причем часто существует много способов сделать одно и то-же.
