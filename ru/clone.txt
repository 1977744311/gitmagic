== Все о клонировании ==

В старых системах контроля версий стандартная операция для получения файлов — это checkout. Вы получаете файлы в конкретном сохраненном состоянии.

В Git и других распределенных системах контроля версий стандартный способ — клонирование. Для получение файлов вы создаете «клон» всего хранилища. Другими словами, вы создаете зеркало центрального сервера. При этом все что можно делать в основном хранилище, можно делать и в локальном.

=== Синхронизация компьютеров ===

Я вполне приемлю синхронизацию архивами или использование *rsync* для резервного копирования и простейшей синхронизации. Но я работаю то на ноутбуке, то на стационарном компьютере, которые могут никак между собой не взаимодействовать между этим.

Создайте хранилище Git и сделайте коммит файлов на одном компьютере. А потом выполните на другом

 $ git clone другой.компьютер:/путь/к/файлам

для создания второй копии файлов и хранилища Git. С этого момента

 $ git commit -a
 $ git pull другой.компьютер:/путь/к/файлам HEAD

синхронизирует состояние ваших файлов с состоянием файлов другого компьютера. Если вы внесли конфликтующие изменения в один и тот же файл, Git даст вам знать, и нужно будет сделать коммит еще раз, после устранения конфликта.

=== Классический контроль исходного кода ===

Создайте хранилище Git для ваших файлов:

 $ git init
 $ git add .
 $ git commit -m "Начальный коммит"

На центральном сервере создайте т.н. «голое» (bare) хранилище Git с неким именем:

 $ mkdir proj.git
 $ cd proj.git
 $ git init --bare
 $  # вариант «в одну строчку»: GIT_DIR=proj.git git init

Запустите Git-демон, если необходимо:

 $ git daemon --detach # возможно уже запущен

Для создания нового пустого хранилища Git на публичных серверах следуйте их инструкциям. Обычно, нужно заполненить форму на веб-странице.

Отправьте ваши изменения в центральное хранилище вот так:

 $ git push git://центральный.сервер/путь/к/proj.git HEAD

Для получения ваших исходников разработчик вводит

 $ git clone git://центральный.сервер/путь/к/proj.git

После внесения изменений разработчик сохраняет изменения локально:

 $ git commit -a

Для обновления до последней версии:

 $ git pull

Любые конфликты слияния нужно разрешить и закоммитить:

 $ git commit -a

Для закачки локальных изменений в центральное хранилище:

 $ git push

Если на главном сервере были новые изменения, сделанные другими разработчиками, команда push прервётся с ошибкой. В этом случае разработчику нужно будет сгрузить к себе (pull) последнюю версию, разрешить возможные конфликты слияний и попробовать ещё раз.

=== Голые (bare) хранилища ===

Голое (bare) хранилище называются так потому, что у него нет рабочего каталога. Оно содержит только файлы, которые обычно скрыты в подкаталоге .git. Другими словами, голое хранилище содержит историю изменений, но не содержит снимка какой-либо определенной версии.

Голое хранилище играет роль, похожую на основной сервер в централизованной системе контроля версий: это дом вашего проекта. Разработчики клонируют с него проект и закачивают в него свежие официальные изменения. Как правило, он располагается на сервере, который мало что делает, кроме раздачи данных. Разработка идет в клонах, поэтому домашнее хранилище может обойтись и без рабочего каталога.

Многие команды Git не работают в голых хранилищах, если переменная среды `GIT_DIR` не содержит путь до хранилища или не указан параметр `--bare`.

=== Push или pull? ===

Зачем вводится команда push, вместо использования уже знакомой pull? Прежде всего, pull не работает в голых хранилищах, вместо нее нужно использовать команду 'fetch', которая будет рассмотрена позже. Но даже если держать на центральном сервере нормальное хранилище, использование команды pull в нем будет затруднительным. Нужно будет сначала войти на сервер интерактивно и сообщить команде pull адрес машины, с которой мы хотим забрать изменения. Этому могут мешать сетевые брандмауэры (firewall), но в первую очередь: что если у нас нет интерактивного доступа к серверу?

Тем не менее, не рекомендутся push-ить в хранилище, помимо этого случая, из-за путаницы, которая может возникнуть, если у целевого хранилища есть рабочий каталог.

Короче, пока изучаете Git, push-те только в голые хранилища. В остальных случаях pull-те.

=== Создание форка проекта ===

Не нравится путь развития проекта? Думаете, можете сделать лучше? Тогда на Вашем сервере:

 $ git clone git://main.server/path/to/files

Теперь расскажите всем об ответвлении (форке, прим. пер) проекта на вашем сервере.

Позже вы сможете в любой момент втянуть к себе изменения из первоначального проекта:

 $ git pull

=== Максимальные бэкапы ===

Хотите создать множество защищенных, географически разнесенных резервных архивов? Если в вашем проекте много разработчиков, делать ничего не надо! Каждый клон — это и есть бэкап не только текущего состояния, но и всей истории изменений проекта. Благодаря криптографическому хэшированию, повреждение какого-либо из клонов будет обнаружено при первой же попытке взаимодействия с другими клонами.

Если ваш проект не такой популярный, размещайте клоны на как можно большем количестве серверов.

Особо беспокоящимся рекомендуется всегда записывать самый последний 20-байтный SHA1 хэш HEAD в безопасном месте. В безопасном, но не тайном. Например, хороший вариант — публикация в газете, потому как сложно изменить каждую копию газеты.

=== Многозадачность со скоростью света ===

Скажем, вы хотите работать над несколькими функциями параллельно. Тогда закоммитьте ваши изменения и запустите

  $ git clone . /some/new/directory

При создании такого клона Git использует жесткие ссылки и обмен файлами столь интенсивно, насколько это возможно при должной безопасности; так что он будет готов мгновенно, и вы теперь сможете работать с двумя независимыми функциями одновременно. Например, можно редактировать один клон, компилируя в это время другой.

В любое время можно сделать коммит и вытянуть изменения из другого клона:

 $ git pull /the/other/clone HEAD

=== Партизанский контроль версий ===

Вы работаете над проектом, который использует другую систему контроля версий, и вам очень не хватает Git? Тогда создайте хранилище Git в своём рабочем каталоге:

 $ git init
 $ git add .
 $ git commit -m "Initial commit"

затем склонируйте его в новый каталог:

 $ git clone . /some/new/directory

Теперь перейдите в этот новый каталог и работайте в нём с Git в своё удовольствие. Когда вам понадобиться синхронизировать изменения с другими, перейдите в изначальный каталог и синхронизируйтесь с помощью другой системы контроля версий, затем наберите

 $ git add .
 $ git commit -m "Синхронизироваться с другими"

Теперь перейдите в новый каталог и запустите

 $ git commit -a -m "Описание моих изменений"
 $ git pull

Процедура передачи изменений остальным зависит от используемой системы контроля версий. Новый каталог содержит файлы с вашими изменениями. Для загрузки файлов в центральное хранилище запускайте любые необходимые команды другой системы контроля версий.

Subversion (вероятно, наилучшая централизованная система контроля версий) используется неисчислимым множествов проектов. Команда *git svn* автоматизирует этот процесс для хранилищ Subversion и может быть использована для http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html[экспорта проекта Git в хранилище Subversion].
