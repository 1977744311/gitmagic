== Все о клонировании ==

В старых системах контроля версий стандартная операция для получения файлов — это checkout. Вы получаете файлы в конкретном сохраненном состоянии.

В Git и других распределенных системах контроля версий стандартный способ — клонирование. Для получения файлов вы создаете «клон» всего репозитория. Другими словами, вы создаете зеркало центрального сервера. При этом все, что можно делать в основном репозитории, можно делать и в локальном.

=== Синхронизация компьютеров ===

Я вполне приемлю синхронизацию архивами или использование *rsync* для резервного копирования и простейшей синхронизации. Но я работаю то на ноутбуке, то на стационарном компьютере, которые могут никак между собой не взаимодействовать между этим.

Создайте репозиторий Git и сделайте коммит файлов на одном компьютере. А потом выполните на другом

 $ git clone другой.компьютер:/путь/к/файлам

для создания второй копии файлов и репозитория Git. С этого момента

 $ git commit -a
 $ git pull другой.компьютер:/путь/к/файлам HEAD

синхронизирует состояние ваших файлов с состоянием файлов другого компьютера. Если вы внесли конфликтующие изменения в один и тот же файл, Git даст вам знать, и нужно будет сделать коммит еще раз, после устранения конфликта.

=== Классический контроль исходного кода ===

Создайте репозиторий Git для ваших файлов:

 $ git init
 $ git add .
 $ git commit -m "Начальный коммит"

На центральном сервере создайте т.н. «голый» (bare) репозиторий Git с неким именем:

 $ mkdir proj.git
 $ cd proj.git
 $ git init --bare
 $  # вариант «в одну строчку»: GIT_DIR=proj.git git init

Запустите Git-демон, если необходимо:

 $ git daemon --detach # возможно уже запущен

Для создания нового пустого репозитория Git на публичных серверах следуйте их инструкциям. Обычно, нужно заполненить форму на веб-странице.

Отправьте ваши изменения в центральный репозиторий вот так:

 $ git push git://центральный.сервер/путь/к/proj.git HEAD

Для получения ваших исходников разработчик вводит

 $ git clone git://центральный.сервер/путь/к/proj.git

После внесения изменений разработчик сохраняет изменения локально:

 $ git commit -a

Для обновления до последней версии:

 $ git pull

Любые конфликты слияния нужно разрешить и закоммитить:

 $ git commit -a

Для закачки локальных изменений в центральный репозиторий:

 $ git push

Если на главном сервере были новые изменения, сделанные другими разработчиками, команда push прервётся с ошибкой. В этом случае разработчику нужно будет сгрузить к себе (pull) последнюю версию, разрешить возможные конфликты слияний и попробовать ещё раз.

=== Голые (bare) репозитории ===

Голый (bare) репозиторий называются так потому, что у него нет рабочего каталога. Он содержат только файлы, которые обычно скрыты в подкаталоге `.git`. Другими словами, голый репозиторий содержит историю изменений, но не содержит снимка какой-либо определенной версии.

Голый репозиторий играет роль, похожую на основной сервер в централизованной системе контроля версий: дом вашего проекта. Разработчики клонируют ваш проект с него и закачивают в него свежие официальные изменения. Как правило, он располагается на сервере, который мало что делает, кроме раздачи данных. Разработка идет в клонах, поэтому домашний репозиторий может обойтись без рабочего каталога.

Многие команды Git не работают в голых репозиториях, если переменная среды `GIT_DIR` не содержит путь до репозитория или не указан параметр `--bare`.

=== Push или pull? ===

Зачем вводится команда push, вместо использования уже знакомой pull? Прежде всего, pull не работает в «голом» репозитории, вместо нее нужно использовать команду 'fetch', которая будет рассмотрена позже. Но даже если держать на центральном сервере нормальный репозиторий, использование команды pull в нем будет затруднительным. Нужно будет сначала войти на сервер интерактивно и сообщить команде pull адрес машины, с которой мы хотим забрать изменения. Этому могут мешать сетевые брандмауэры (firewall), но в первую очередь: что если у нас нет интерактивного доступа к серверу?

Тем не менее, не рекомендутся push-ить в репозиторий, кроме этого случая, из-за путаницы, которая может возникнуть, если у целевого репозитория есть рабочий каталог.

Короче, пока изучаете Git, push-те только в «голые» репозитории. В остальных случаях pull-те.

=== Создание форка проекта ===

Не нравится путь развития проекта? Думаете можете сделать лучше? Тогда на Вашем сервере:

 $ git clone git://main.server/path/to/files

Теперь расскажите всем об ответвлении (форке, прим. пер) проекта на вашем сервере.

Позже вы сможете в любой момент втянуть к себе изменения из первоначального проекта:

 $ git pull

=== Максимальные бэкапы ===

Хотите создать множество защищенных, географически разнесенных резервных архивов? Если в вашем проекте много разработчиков, делать ничего не надо! Каждый клон — это и есть бэкап не только текущего состояния, но и всей истории изменений проекта. Благодаря криптографическому хэшированию, повреждение какого-либо из клонов будет обнаружено при первой же попытке взаимодействия с другими клонами.

Если ваш проект не такой популярный, размещайте клоны на как можно большем количестве серверов.

Особо беспокоящимся рекомендуется всегда записывать самый последний 20-байтный SHA1 хэш HEAD в безопасном месте. В безопасном, но не тайном. Например, хороший вариант — публикация в газете, потому как сложно изменить каждую копию газеты.

=== Многозадачность со скоростью света ===

Скажем, вы хотите работать над несколькими функциями параллельно. Тогда закоммитьте ваши изменения и запустите

  $ git clone . /some/new/directory

При создании такого клона Git использует жесткие ссылки и обмен файлами столь интенсивно, насколько это возможно при должной безопасности; так что он будет готов мгновенно, и вы теперь сможете работать с двумя независимыми функциями одновременно. Например, можно редактировать один клон, компилируя в это время другой.

В любое время можно сделать коммит и вытянуть изменения из другого клона:

 $ git pull /the/other/clone HEAD

=== Партизанский контроль версий ===

Вы работаете над проектом, который использует другую систему контроля версий, и вам очень не хватает Git? Тогда создайте репозиторий Git в своём рабочем каталоге:

 $ git init
 $ git add .
 $ git commit -m "Initial commit"

затем склонируйте его в новый каталог:

 $ git clone . /some/new/directory

Теперь перейдите в этот новый каталог и работайте в нём с Git в своё удовольствие. Когда вам понадобиться синхронизировать изменения с другими, перейдите в изначальный каталог и синхронизируйтесь с помощью другой системы контроля версий, затем наберите

 $ git add .
 $ git commit -m "Синхронизироваться с другими"

Теперь перейдите в новый каталог и запустите

 $ git commit -a -m "Описание моих изменений"
 $ git pull

Процедура передачи изменений остальным зависит от используемой системы контроля версий. Новый каталог содержит файлы с вашими изменениями. Для загрузки файлов в центральный репозиторий запускайте любые необходимые команды другой системы контроля версий.

Subversion (вероятно, наилучшая централизованная система контроля версий) используется неисчислимым множествов проектов. Команда *git svn* автоматизирует этот процесс для репозиториев Subversion и может быть использована для http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html[экспорта Git проекта в Subversion репозиторий].
