== Чудеса ветвления == 

Возможности мгновенного ветвления и слияния — самые потрясающие особенности Git.

*Задача*: во время работы неизбежны внешние факторы, влекущие переключение контекста. Серьезная ошибка в уже выпущенной версии проявляется без предупреждения. Срок сдачи конкретного функционала не стоит на месте. Разработчик, помощь которого нужна вам в работе над ключевой частью проекта, собирается в отпуск. Одним словом, вам нужно срочно бросить все, над чем вы трудитесь в настоящий момент, и переключиться на совершенно другие дела.

Прерывание хода ваших мыслей может серьезно снизить эффективность работы, и чем сложнее переключение между процессами, тем больше будет потеря. При централизованном управлении версиями мы вынуждены скачивать свежую рабочую копию с центрального сервера. Распределенная система лучше: мы можем клонировать нужную версию локально.

Однако клонирование все же предполагает копирование всего рабочего каталога, как и всей истории изменений до настоящего момента. Хотя Git и позволяет сэкономить средства за счет возможности совместного использования файлов и жестких ссылок, но все файлы проекта придется полностью воссоздать в новом рабочем каталоге.

*Решение*: у Git есть более удобный инструмент для этих целей, который сэкономит и время, и дисковое пространство по сравнению с клонированием — это *git branch* (branch — ветка, прим. пер.).

Этим волшебным словом файлы в вашем каталоге мгновенно преобразуются с одной версии на другую. Это изменение позволяет сделать намного больше, чем просто вернуться назад или продвинуться вперед в истории. Ваши файлы могут изменится с последней выпущенной версии на экспериментальную, с экспериментальной — на текущую версию в разработке, с неё — на версию вашего друга и так далее.

=== Кнопка босса ===

Наверняка, вы играли в одну из таких игр, где при нажатии определеной клавиши («кнопки босса»), игра быстро сворачивается и на экране отображается рабочая таблица или что-нибудь другое? То есть, если в офис зашел начальник, а вы играете в игру, вы должны уметь быстро ее скрыть.

В каком-нибудь каталоге:

 $ echo "Я хитрее моего босса" > myfile.txt 
 $ git init 
 $ git add .  
 $ git commit -m "Начальный коммит"
 
Мы создали хранилище Git, содержащее один текстовый файл с определенным сообщением. Теперь выполните

 $ git checkout -b boss # вероятно, это последнее изменение
 $ echo "Мой босс меня умнее" > myfile.txt
 $ git commit -a -m "Другой коммит"
 
Похоже на то, как будто мы перезаписали файл и сделали коммит. Но это иллюзия. Наберите

 $ git checkout master # переключиться на оригинальную версию файла

Вуаля! Текстовый файл восстановлен. И если босс решить сунуть нос в этот каталог, запустите

 $ git checkout boss # перейти на специальную версию для босса

Вы можете переключаться между двумя версиями этого файла так часто, как вам хочется и делать коммиты каждой из них независимо.

=== Грязная работа ===

[[branch]]
Допустим, вы работаете над созданием какой-либо функции, и вам зачем-то понадобилось вернуться на три версии назад и временно добавить несколько операторов вывода, чтобы посмотреть как что-либо работает. Тогда введите

 $ git commit -a
 $ git checkout HEAD~3

Теперь вы можете добавлять временный черновой код в любых местах. Можно даже закоммитить эти изменения. Когда закончите, выполните

 $ git checkout master

чтобы вернуться к исходной работе. Заметьте, что любые изменения, не внесенные в коммит, будут перенесены.

А что, если вы все-таки хотели сохранить временные изменения? Пожалуйста:

 $ git checkout -b dirty

а затем сделайте коммит, прежде чем переключеться на ветвь master. Всякий раз когда вы захотите вернуться к черновым изменениям, просто выполните

 $ git checkout dirty

Мы говорили об этой команде в одной из предыдущих глав, когда обсуждали загрузку старых состояний. Теперь у нас перед глазами полная картина: файлы изменились к нужному состоянию, но мы должны оставить ветвь master. Любые коммиты, сделанные с этого момента, направят файлы по другому пути, который может быть указан позже.

Другими словами, после переключения на более старое состояние Git автоматически направляет вас в новую безымянную ветвь, которой можно дать имя и сохранить с помощью *git checkout -b*.

=== Быстрые исправления ===

Ваша работа в самом разгаре, когда вдруг выясняется, что нужно все бросить и исправить только что обнаруженную ошибку в коммите «1b6d…»:

 $ git commit -a
 $ git checkout -b fixes 1b6d

Затем, после того, как вы исправили ошибку, сделайте

 $ git commit -a -m "Ошибка исправлена"
 $ git push # в центральное хранилище
 $ git checkout master

и вернитесь к работе над вашими исходными задачами.

Вы можете даже «влить» только сделанное вами исправление ошибки, набрав

 $ git merge fixes

или

 $ git pull

т.к. вы уже отправили это исправление в основное хранилище.

=== Слияния ===

В некоторых системах контроля версий создавать ветки легко, а вот слвать их воедино трудно. В Git слияние столь тривиально, что вы можете его не заметить.

Действительно, хотя мы только познакомились с *git merge*, мы сталкивались со слияниями уже давно. Команда *pull* по сути получает коммиты, а затем сливает их с вашей текущей веткой. Если у вас нет локальных изменений, слияние вырожденное: это то же самое, что и получение последней версии в централизованной системе контроля версий. Если же у вас есть локальные изменения, Git автоматически произведёт слияние и сообщит о любых конфликтах.

Обычно у коммита есть один «родитель», а именно, предыдущий коммит. Слияние веток приводит к коммиту как минимум с двумя родителями. Отсюда возникает вопрос: к какому коммиту на самом деле отсылает HEAD~10? Коммит может иметь несколько родителей, так за которым из них следовать далее?

Оказывается, такая запись всегда выбирает первого родителя. Это хороший выбор, потому что коммиты в текущей ветке становятся первыми родителями во время слияния. Часто вас интересуют только изменения, сделанные вами в текущей ветке, а не те, которые влились из других веток.

Вы можете обращаться к конкретному родителю с помощью символа «^». Например, чтобы показать запись в журнале от второго родителя,

 $ git log HEAD^2

Вы можете опустить номер для первого родителя. Например, чтобы показать разницу с первым родителем,

 $ git diff HEAD^

Вы можете сочетать такую запись с другими. Например,

 $ git checkout 1b6d^^2~10 -b ancient

создаст новую ветку «ancient» («древняя», прим. пер.), отражающую состояние на десять коммитов назад от второго родителя первого родителя коммита, начинающегося с 1b6d.

=== Непрерывный рабочий процесс ===

В некоторых проектах ваш код должен быть проверен, прежде чем будет принят. Если вы сделали значительные изменения, то для облегчения задачи тем, кто будет проверять ваш код, разбивайте ваши изменения на 2 или более частей и выкладывайте по одной для проверки.

А что, если вторую часть нельзя записать до того, как первая часть проверена и принята? Во многих системах управления версиями отправить на рассмотрение вторую часть можно только после утверждения первой части.

На самом деле это не совсем правда, но необходимость в таких системах редактировать часть II перед тем, как отправить часть I, связана с трудностями и неудобствами. В Git ветвление и слияние безболезненно (это техническая аллегория для «быстрее и на локальном уровне»). Поэтому, после создания коммита первой части и направления его для рассмотрения сделайте

 $ git checkout -b part2

Теперь пишите вторую часть, не ожидая принятия первой. После того, как первая часть утверждена и выложена,

 $ git checkout master 
 $ git merge part2 
 $ git branch -d part2 # эта ветка больше не нужна

и вторая часть правок готова к проверке.

Но стоп! Что, если не все так просто? Скажем, в первой части вы сделали ошибку, которую нужно было исправить до отправки. Запросто! Во-первых, вернитесь в ветку master с помощью

 $ git checkout master

Исправьте найденное в первой части и отправьте на проверку. Если же её не примут, можно просто повторить этот шаг. Вы, вероятно, также захотите влить исправления части I в часть II:

 $ git checkout part2 
 $ git merge master

Теперь они такие же, как раньше. После того, как первая часть утверждена и выложена,

 $ git checkout master 
 $ git merge part2
 $ git branch -d part2

и вторая часть, как и в прошлый раз, готова к проверке.

Вы можете легко использовать этот трюк для любого количества частей.

=== Изменяем состав смеси ===

Предположим, вам нравится работать над всеми аспектами проекта в одной и той же ветке. Вы хотите закрыть свой рабочий процесс от других, чтобы все видели ваши коммиты только после того, как они будут хорошо оформлены. Создайте пару веток:

 $ git checkout -b sanitized
 $ git checkout -b medley

Далее делайте всё что нужно: исправляйте ошибки, добавляйте новые функции, добавляйте временный код и т.д., при этом почаще выполняя коммиты. После этого

 $ git checkout sanitized 
 $ git cherry-pick medley^^

применит коммит «пра-родителя» головы ветки «medley» к ветке «sanitized». Правильно подбирая элементы, вы сможете создать ветку, в которой будет лишь окончательный код, а связанные между собой коммиты будут собраны вместе.

=== Управление Ветками ===

Для просмотра списка всех веток наберите:

 $ git branch

По умолчанию вы начинаете работать с ветки под названием «master». Кому-то нравится оставлять ветку «master» нетронутой и создавать новые ветки со своими изменениями.

Опции *-d* и *-m* позволяют удалять и перемещать (переименовывать) ветки.

См. *git help branch*.

Ветка «master» — это удобная традиция. Другие могут предполагать, что в вашем хранилище есть ветка с таким именем, содержащая официальную версию проекта. Хотя вы можете переименовать или удалить ветку «master», лучше соблюсти общее соглашение.

=== Временные Ветки ===

Через какое-то время вы можете обнаружить, что создаете множество временных веток для одной и той краткосрочной цели: нужно сохранить текущее состояние, чтобы была возможность вернуться назад и исправить грубую ошибку или сделать что-то еще.

Это похоже на то, как вы переключаете телевизионные каналы, чтобы посмотреть что показывают по другим. Но здесь, вместо того, чтобы нажать на пару кнопок на пульте, нужно будет создавать, выбирать (checkout), сливать (merge) а затем удалять временные ветки. К счастью, в Git есть удобная команда, имитирующая работу пульта дистанционного правления.

 $ git stash

Эта команда сохранит текущее состояние в во временном месте («тайнике») и востановит предыдущее состояние. Ваш каталог становиться точно таким, каким был до начала редактирования, и вы можете исправить ошибки, загрузить удаленные изменения и т.п. Когда вы хотите вернуться назад в состояние «тайника», наберите:

 $ git stash apply # Возможно, понадобится устранить какие-либо конфликты.

Можно создавать несколько тайников, используя их разными способами. См. *git help stash*. Как вы могли догадаться, Git удерживает ветки «за кадром» при выполнении этого чудесного приема.

=== Работайте как вам нравится ===

Такие приложения как http://www.mozilla.com/[Mozilla Firefox] позволяют открывать несколько вкладок и несколько окон. Переключение вкладок позволяет видеть разное содержание в одном и том же окне. Ветки в Git подобны вкладкам для вашего рабочего каталога. И, продолжая аналогию, клонирование — это открытие нового окна. Сочетание обоих инструментов расширяет ваши возможности. 

На более высоком уровне, многие оконные менеджеры Linux поддерживают несколько рабочих столов. Ветки в Git подобны переключению на другой рабочий стол, а клонирование подобно подключению дополнительного монитора для получения ещё одного рабочего стола.

Другой пример — это утилита http://www.gnu.org/software/screen/[*screen*]. Этот самородок позволяет создавать, уничтожатьать и переключаться между множеством терминальных сессий в одном и том же терминале. Вместо открытия нового терминала (клонирования), можно использовать этот же, запустив *screen* (создать ветку). На самом деле у *screen* гораздо больше возможностей, но это уже тема для другой книги.

Клонирование, ветвление и слияние в Git — быстые локальные операции, что позволяет вам сочетать их наиболее удобным вам способом. Git позволяет работать именно так, как вам хочется.
