== Piyrsze szryty ==

Zanim utopisz sie w morzu polecyń Gita, zyrknij nojpiyrw na pora komyndow Gita. Choć som ajnfachowe, to som ważne i sie wnet przidajom. Powiym prowda, jak zaczłech pracować z Git, to przez pora miesiyncy niy potrzebowołech żodnych innych polecyń, kierch byś sam niy znaloz, w tym rozdziale.

=== Zicherowanie łobecnego stanu ===

Chcołbyś drapko zabrać sie do roboty? Zrob piyrw zicherung danych twojego roboczego kataloga.

 $ git init
 $ git add .
 $ git commit -m "Mój pierwszy commit"

Jakbyś potym coś spaproł, możesz pujś nazot do piyrwotnyj wersji.

 $ git reset --hard

Jakbyś chcioł tyn stan teraz zapamiyntać:

 $ git commit -a -m "Mój następny commit"

=== Dodanie, kasowanie i zmiana nazwy ===
=== Dodanie, kasowanie i zmiynianie nazwy ===

Ta komynda zatrzimo pliki, kiere żeś dodoł za piyrszym razym przy *git add*. A jak mosz jakieś nowe pliki, dej tyż ło tym znać Gitowi.

 $ git add readme.txt Dokumentacja

To samo, jak byś chcioł, żeby Git zapomnioł ło jakichś plikach:

 $ git rm ramsch.h archaiczne.c 
 $ git rm -r obciążający/materiał/

Jak byś tego jeszcze som niy zrobił, to Git wyciepnie pliki za ciebie.

Zmiyniynie nazwy plika, to to samo co wyciepanie go i skudzynie nazot pod innom nazwom. Git biere sam skrot *git mv*, kiery mo ta samo składnia co komynda *mv*. Na przikład:

 $ git mv bug.c feature.c

=== Zaawansowane anulowanie/prziwrocanie ===

Czasym chciołbyś ajnfach ino sie nazot w czasie cofnońć i zapomnieć o zmianach kiere żeś potym wciepoł. Komynda: 

 $ git log

pokoże ci lista 'commits' i ich sum kontrolnych SHA1:
----------------------------------
commit 766f9881690d240ba334153047649b8b8f11c664 Author: Bob <bob@example.com>
Date: Tue Mar 14 01:59:26 2000 -0800

    Zamień printf() mit write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alicja <alicja@example.com>
Date: Thu Jan 1 00:00:00 1970 +0000

    Initial commit. 
---------------------------------- 

Kilka początkowych znaków klucza SHA1 wystarcza by jednoznacznie zidentyfikować 'commit', alternatywnie możesz skopiować i wkleić cały klucz. Wpisując:

 $ git reset --hard 766f

przywrócisz stan do stanu podanego 'commit', a wszystkie późniejsze zmiany zostaną bezpowrotnie skasowane.

Innym razem chcesz tylko na moment przejść do jednego z poprzednich stanów. W tym wypadku użyj komendy:

 $ git checkout 82f5

Tym poleceniem wrócisz się w czasie zachowując nowsze zmiany. Ale, tak samo jak w podróżach w czasie z filmów science-fiction - jeśli teraz dokonasz zmian i zapamiętasz je poleceniem 'commit', zostaniesz przeniesiona do alternatywnej rzeczywistości, ponieważ twoje zmiany różnią się od dokonanych w późniejszych punktach czasu.

Tą alternatywną rzeczywistość nazywamy 'branch', a <<branch,zajmiemy się tym w późniejszym czasie>>. Na razie, zapamiętaj tylko, że:

 $ git checkout master

sprowadzi cię znów do teraźniejszości. Również, aby uprzedzić narzekanie Gita, powinieneś przed każdym 'checkout' wykonać 'commit' lub 'reset'.

Korzystając ponownie z analogii do gier komputerowych:

- *`git reset --hard`*: załaduj jakiś starszy stan gry i skasuj wszystkie nowsze niż właśnie ładowany.

- *`git checkout`*:  Załaduj stary stan, grając dalej, twój stan będzie się różnił od nowszych zapamiętanych. Każdy stan, który zapamiętasz od teraz, powstanie w osobnym 'branch', reprezentującym alternatywną rzeczywistość. <<branch,Wrócimy do tego później>>

Jeśli chcesz, możesz przywrócić jedynie wybrane pliki lub katalogi poprzez dodanie ich nazw do polecenia

 $ git checkout 82f5 jeden.plik inny.plik

Bądź ostrożny, ten sposób użycia komendy *checkout* może bez uprzedzenia skasować pliki. Aby zabezpieczyć eis przed takimi wypadkami powinieneś zawsze wykonać polecenie 'commit' zanim wykonasz 'checkout', szczególnie w okresie poznawania Gita. Jeśli czujesz się niepewnie przed wykonaniem jakiejś operacji Gita, generalną zasadą powinno stać się dla ciebie uprzednie wykonanie *git commit -a*.

Nie lubisz kopiować i wklejać kluczy SHA1? Możesz w tym wypadku skorzystać z:

 $ git checkout :/"Mój pierwszy c"

by przenieś się do 'commit', którego opis rozpoczyna zawartą wiadomość. Możesz również cofnąć się do piątego z ostatnio zapamiętanych 'commit':

 $ git checkout master~5

=== Przywracanie ===

W sali sądowej pewne zdarzenia mogą zostać wykreślone z akt. Podobnie możesz zaznaczyć pewne 'commits' do wykreślenia.

 $ git commit -a 
 $ git revert 1b6d

To polecenie wymaże 'commit' o wybranym kluczu. ten rewers zostanie zapamiętany jako nowy 'commit', co można sprawdzić poleceniem *git log*.

=== Generowanie listy zmian ===

Niektóre projekty wymagają http://en.wikipedia.org/wiki/Changelog[pliku changelog]. Wygenerujesz go poleceniem:

 $ git log > Changelog

=== Ładowanie plików ===

Kopię projektu zarządzanego za pomocą Gita uzyskasz poleceniem:

 $ git clone git://ścieżka/do/projektu

By na przykład zładować wszystkie dane, których użyłem do stworzenia tej strony skorzystaj z:

 $ git clone git://git.or.cz/gitmagic.git

Do polecenia 'clone' wrócimy niebawem.

=== Najnowszy stan ===

Jeśli posiadasz już kopię projektu wykonaną za pomocą *git clone*, możesz ją zaktualizować poleceniem:

 $ git pull

=== Szybka publikacja ===

Przypuśćmy, że napisałeś skrypt i chcesz go udostępnić innym. Mogłabyś poprosić ich, by zładowali go bezpośrednio z twojego komputera. Jeśli jednak zrobią podczas gdy gdy ty wprowadzasz poprawki lub eksperymentujesz ze zmianami, mogłabyś przysporzyć im nieprzyjemności. Z tego powodu istnieje coś takiego jak cykl wydawniczy. Programiści regularnie pracują nad projektem, upubliczniają kod jednak dopiero, jeśli uznają, że nadaje się już do pokazania.

Aby wykonać to za pomocą GIT, wejdź do katalogu w którym znajduje się twój skrypt:

 $ git init
 $ git add .
 $ git commit -m "Pierwsze wydanie"

Następnie poproś twych użytkowników o wykonanie:

 $ git clone twój.komputer:/ścieżka/do/skryptu

by zładować twój skrypt. Zakładamy tu posiadanie przez nich klucza SSH do twojego komputera. Jeśli go nie mają, uruchom *git daemon* i podaj im następujący link:

 $ git clone git://twój.komputer/ścieżka/do/skryptu

Od teraz, zawsze gdy uznasz, że wersja nadaje się do opublikowania, wykonaj polecenie:

 $ git commit -a -m "Następna wersja"

a twoi użytkownicy, po wejściu do katalogu zawierającym twój skrypt, będą go mogli zaktualizować poprzez:

 $ git pull

Twoi użytkownicy nigdy nie wejdą w posiadanie wersji, których nie chcesz im udostępniać.

=== A co robiłem ostatnio? ===

Jeśli chcesz zobaczyć zmiany, które wprowadziłeś of ostatniego 'commit', wpisz:

 $ git diff

Albo tylko zmiany od wczoraj:

 $ git diff "@{yesterday}"

Albo miedzy określoną wersją i dwoma poprzedzającymi:

 $ git diff 1b6d "master~2"

Za każdym razem uzyskane informacje są równocześnie patchem, który poprzez *git apply* może zostać być zastosowany. Spróbuj również:

 $ git whatchanged --since="2 weeks ago"

Jeśli chcę sprawdzić listę zmian jakiegoś repozytorium, często korzystam często z  http://sourceforge.net/projects/qgit[qgit], ze względu na jego fotogeniczny interfejs, albo z http://jonas.nitro.dk/tig/[tig], tekstowy interfejs, działający zadowalająco gdy mamy do czynienia z wolnym łączem internetowym. Alternatywnie, zainstaluj serwer http, uruchom *git instaweb*, i odpal dowolną przeglądarkę internetową.

=== Ćwiczenie ===

Niech A, B, C i D będą 4 następującymi po sobie 'commits', gdzie B różni się od A, jedynie tym, iż usunięto kilka plików. Chcemy teraz te usunięte pliki zrekonstruować do D. Jak to można zrobić?

Istnieją przynajmniej 3 rozwiązania. Załóżmy że znajdujemy się obecnie w D:

1. Różnica pomiędzy A i B, to skasowane pliki. Możemy utworzyć patch, który pokaże te różnice i następnie zastosować go:

 $ git diff B A | git apply

2. Ponieważ pliki zostały już raz zapamiętane w A, możemy je przywrócić:

 $ git checkout A foo.c bar.h

3. Możemy też widzieć przejście z A na B jako zmianę, którą można zrewertować:

 $ git revert B

A które z tych rozwiązań jest najlepsze? To, które najbardziej tobie odpowiada. Korzystając z Git łatwo osiągnąć cel, czasami prowadzi do niego wiele dróg.
