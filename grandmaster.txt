= Git Grandmastery =

This pretentiously named page is my dumping ground for uncategorized Git tricks.

== Source Releases ==

For my projects, Git tracks exactly the files I'd like to archive and release to users. So to create a tarball of the source code, I run:

 $ git-archive --format=tar --prefix=proj-1.2.3/ HEAD

== Changelog Generation ==

It's good practice to keep a [[http://en.wikipedia.org/wiki/Changelog][changelog]], and some projects even require it. If you've been committing frequently, which you should, generate a Changelog by typing

 $ git-log > ChangeLog

== Git Over SSH, HTTP ==

Suppose you have ssh access to your web server, and it does not have Git installed, which is not an uncommon situation. Then download, compile and install Git in your account.

Create a repository in your web directory:

 $ GIT_DIR=proj.git git-init

and in the "proj.git" directory, run

 $ git --bare update-server-info
 $ chmod a+x hooks/post-update

From your computer, you can push via ssh:

 $ git push web.server:/path/to/proj.git HEAD

and people can get your project via

 $ git clone http://web.server/proj.git

== Commit What Changed ==

Telling Git when you've added, deleted and renamed files gets tedious. Instead, try:

 $ git-ls-files -d -m -o -z | xargs -0 git-update-index --add --remove

and Git will look at the files in the current directory and work everything out for itself. The *-z* and *-0* options prevent ill side-effects from filenames containing strange characters.

You might want it to ignore particular files:

 $ git-ls-files -d -m -o -z -x *.tmp | xargs -0 git-update-index --add --remove

If you have a big list of directories and files that should never be version controlled, type them into a separate file named ".gitignore" and run:

 $ git-ls-files -d -m -o -z -X .gitignore | xargs -0 git-update-index --add --remove

You can also exclude files on a per-directory basis. See the help page.

== I Stand Corrected ==

Did you just commit, but wish you had typed a different message? Realized you forgot to add a file? Then:

 $ git commit --amend

can help you out.

== Don't Lose Your HEAD ==

The HEAD tag is like a cursor that normally points at the latest commit, advancing with each new commit. Some Git commands let you move it. For example:

 $ git reset HEAD~3

will move the HEAD three commits backwards in time. Thus all Git commands now act as if you hadn't made those last three commits, while your files remain in the present. See the git-reset man page for some applications.

But how can you go back to the future? The past commits do not know anything of the future.

If you have the SHA1 of the original HEAD then:

 $ git reset SHA1

But suppose you never took it down? Don't worry, for commands like these, Git saves the original HEAD as a tag called ORIG_HEAD, and you can return safe and sound with:

 $ git reset ORIG_HEAD

== Building On Git ==

In true UNIX fashion, Git's design allows it to be easily used as a low-level component of other programs. There are GUI interfaces, web interfaces, alternative command-line interfaces, and perhaps soon you will have a script or two of your own that calls Git.

See [[http://git.or.cz/][the Git homepage]] for some examples.
