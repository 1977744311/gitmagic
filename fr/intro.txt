== Introduction ==

Je vais me servir d'une analogie pour présenter la gestion de versions. Référez-vous à http://fr.wikipedia.org/wiki/Gestion_de_versions[la page de wikipedia sur la gestion de versions] pour une explication plus censée.

=== Le Travail comme un jeu ===

J'ai joué à des jeux vidéos presque toute ma vie. Par contre, je n'ai commencé à utiliser des systèmes de gestion de versions qu'à l'age adulte. Je suspect ne pas être le seul et comparer les deux peuvent rendre les concepts plus simples à expliquer et à comprendre.

Pensez à l'édition de votre code, ou document, comme s'il sagissait de jouer à un jeux. Quand vous avez bien progressé, vous aimeriez faire une sauvegarde. Pour cela vous cliquez sur le bouton 'enregistrer' de votre éditeur de confiance.

Mais ceci va écraser l'ancienne version. C'est comme ces jeux anciens qui n'avaient qu'un emplacement : oui vous pouviez faire une sauvegarde, mais vous ne pouviez pas revenir dans un état précédent. Quel dépit, vu que votre sauvegarde précédente pouvait éventuellement être situé à un passage du jeu particulièrement amusant sur lequel vous seriez bien revenu un de ces jours. Ou encore pire, votre sauvegarde actuelle est dans un état qui ne permet pas de gagner, et vous devez tout recommencer à zéro.

=== Gestion de versions ===

Lorsque vous modifiez un document vous pouvez l'"Enregistrer Sous …" un nom de fichier différent, ou copier le fichier quelque part avant de l'enregistrer si vous voulez pouvoir savourez les anciennes versions. Vous pouvez même les compresser pour gagner de l'espace. C'est une forme primitive et laborieuse de gestion de versions. Les jeux vidéo ce sont amélioré sur ce point depuis longtemps, un grand nombre proposant différent emplacements de sauvegarde automatiquement horodatés.

Rendons le problème légèrement plus coriace. Imaginez que vous ayez un ensemble de fichier qui vont ensemble comme le code source d'un projet, ou les fichiers pour un site web. Dans ce cas si vous voulez conserver une ancienne version, vous devez archiver le dossier en entier. Conserver un grand nombre de versiors à la main n'est pas pratique.

Dans le cas de certains jeux vidéo, l'enregistrement d'une partie consiste vraiment en un dossier rempli de fichiers. Ces jeux cachent ce détail au joueur et présentent une interface adaptée pour gérer différentes versions de ce dossier.

Les systèmes de gestion de versions ne font pas autre chose. Ils ont tous de belles interfaces pour gérer des dossiers de trucs. Vous pouvez enregistrer l'état du dossier aussi souvent que vous voulez et vous pouvez recharget l'un des états enregistré plus tard. À la différence de la plupart des jeux vidéos, ils sont générallement forts pour économiser l'espace. Typiquement, seul quelques fichiers changent entre une version et une autre, et pas de beaucoup. Stocker les differences au lieu de copies entièrement nouvelles économise de l'espace.

=== Gestion Distribuée ===

Imaginez maintenant un jeux vidéo très difficile. Si difficile à terminer que plein de joueurs expérimentés de toute la planête décident de faire équipe et de partager leurs parties enregistrées pour essayer d'en venir à bout. http://fr.wikipedia.org/wiki/Speedrun[Les Speedruns] sont un exemple concret : des joueurs qui se spécializent dans différents niveaux du même jeux collaborent pour produire des résultats surprenants.

Comment mettriez-vous en place un système pour qu'ils puissent accéder facilement aux sauvegardes les uns des autres ? Et puissent en téléverser de nouveaux ?

Dans le passé, tout les projets utilisaient une gestion de version centralisée. Quelque part un serveur contenait l'ensemble des sauvegardes du jeux et personne d'autre. Chaque joueur conservait au plus quelques sauvegardes de parties sur leur machine. Quand un joueur voulait progresser, il téléchargeait les dernières sauvegardes du serveur, jouait un moment, sauvegardait et téléversait à nouveau sur le serveur pour mettre à disposition de tous les autres.

What if a player wanted to get an older saved game for some reason? Maybe the current saved game is in an unwinnable state because somebody forgot to pick up an object back in level three, and they want to find the latest saved game where the game can still be completed. Or maybe they want to compare two older saved games to see how much work a particular player did.

There could be many reasons to want to see an older revision, but the outcome is the same. They have to ask the central server for that old saved game. The more saved games they want, the more they need to communicate.

The new generation of version control systems, of which Git is a member, are known as distributed systems, and can be thought of as a generalization of centralized systems. When players download from the main server they get every saved game, not just the latest one. It's as if they're mirroring the central server.

This initial cloning operation can be expensive, especially if there's a long history, but it pays off in the long run. One immediate benefit is that when an old save is desired for any reason, communication with the central server is unnecessary.

=== A Silly Superstition ===

A popular misconception is that distributed systems are ill-suited for projects requiring an official central repository. Nothing could be further from the truth. Photographing someone does not cause their soul to be stolen. Similarly, cloning the master repository does not diminish its importance.

A good first approximation is that anything a centralized version control system can do, a well-designed distributed system can do better. Network resources are simply costlier than local resources. While we shall later see there are drawbacks to a distributed approach, one is less likely to make erroneous comparisons with this rule of thumb.

A small project may only need a fraction of the features offered by such a
system, but using systems that scale poorly for tiny projects is like using
Roman numerals for calculations involving small numbers.

Moreover, your project may grow beyond your original expectations. Using Git from the outset is like carrying a Swiss army knife even though you mostly use it to open bottles. On the day you desperately need a screwdriver you'll be glad you have more than a plain bottle-opener.

=== Merge Conflicts ===

For this topic, our computer game analogy becomes too thinly stretched. Instead, let us again consider editing a document.

Suppose Alice inserts a line at the beginning of a file, and Bob appends one at the end of his copy. They both upload their changes. Most systems will automatically deduce a reasonable course of action: accept and merge their changes, so both Alice's and Bob's edits are applied.

Now suppose both Alice and Bob have made distinct edits to the same line. Then it is impossible to proceed without human intervention. The second person to upload is informed of a _merge conflict_, and must choose one edit over another, or revise the line entirely.

More complex situations can arise. Version control systems handle the simpler cases themselves, and leave the difficult cases for humans. Usually their behaviour is configurable.
