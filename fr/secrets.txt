// -*- mode: doc; mode: visual-line; mode: flyspell; coding: utf-8; -*-
== Les secrets dévoilés ==

Nous allons jeter un oeil sous le capot pour comprendre comment Git réalise ses miracles. Je passerai sous silence la plupart des détails. Pour des explications plus détaillées, référez-vous au http://www.kernel.org/pub/software/scm/git/docs/user-manual.html[manuel utilisateur].

=== L'invisibilité ===

Comment fait Git pour être si discret ? Mis à part lorsque vous faites des commits et des fusions, vous pouvez travailler comme si le contrôle des versions n'existait pas. Et c'est lorsque vous en avez besoin que vous êtes content de voir que Git veillait sur vous tout le temps.

D'autres systèmes de gestion de versions vous mettent constamment aux prises avec de la paperasserie et de la bureaucratie. Les fichiers sont en lecture seule jusqu'à l'obtention depuis un serveur central de l'accord d'édition de tel ou tel fichier. Les commandes les plus basiques voient leurs performances s'écrouler au fur et à mesure que le nombre d'utilisateurs augmente. Le travail s'arrête dès lors que le réseau ou le serveur central est en panne.

À l'inverse, Git conserve tout l'historique de votre projet dans le sous-répertoire `.git` de votre répertoire de travail. C'est votre propre copie de l'historique et vous pouvez donc rester déconnecté tant que vous ne voulez pas communiquer avec les autres. Vous conservez un contrôle total sur le sort de vos fichiers puisque Git peut aisément les recréer à tout moment à partir de l'un des états enregistrés dans `.git`.

=== L'intégrité ===

La plupart des gens associent la cryptographie à la conservation du secret des informations mais l'un de ses buts tout aussi important est de conserver l'intégrité de ces informations. Un usage approprié des fonctions de hachage cryptographiques permet d'empêcher la corruption accidentelle ou malicieuse des données.

Un hash SHA1 peut être vu comme un nombre de 160 bits identifiant de manière unique n'importe quelle suite d'octets que vous rencontrerez dans votre vie. On peut même aller plus loin : c'est vrai pour toutes les suites d'octets que  les humains utiliseront sur plusieurs générations.

Comme un hash SHA1 est lui-même une suite d'octets, nous pouvons  hacher des suites de caractères contenant d'autres hashs. Cette simple observation est étonnamment utile (cherchez par exemple 'hash chains'). Nous verrons plus tard comment Git utilise cela pour garantir efficacement l'intégrité des données.

En bref, Git conserve vos données dans le sous-répertoire `.git/objects` mais à la place des noms de fichiers normaux, vous n'y trouverez que des ID. En utilisant ces ID comme noms de fichiers et grâce à quelques astucieux fichiers de verrouillage et d'horodatage, Git transforme un simple système de fichiers en une base de données efficace et robuste.

=== L'intelligence ===

Comment fait Git pour savoir que vous avez renommé un fichier même si vous ne lui avez pas dit explicitement ? Bien sûr, vous pouvez utiliser *git mv* mais c'est exactement la même chose que de faire *git rm* suivi par *git add*.

Git a des heuristiques pour débusquer les changements de noms et les copies entre les versions successives. En fait, il peut même détecter les bouts de code qui ont été déplacés ou copiés d'un fichier à un autre ! Bien que ne couvrant pas tous les cas, cela marche déjà très bien et cette fonctionnalité est encore en cours d'amélioration. Si cela échoue pour vous, essayez les options activant des méthodes de détection de copie plus coûteuses et envisager de faire une mise à jour.

=== L'indexation ===

Pour chaque fichier suivi, Git mémorise des informations, telles que sa taille et ses dates de création  et de dernières modifications, dans un fichier appelé 'index'. Pour déterminer si un fichier a changé, Git compare son état courant avec ce qu'il a mémorisé dans l'index. Si cela correspond alors Git n'a pas besoin de relire le fichier.

Puisque les appels à 'stat' sont considérablement plus rapide que la lecture des fichiers, si vous n'avez modifié que quelques fichiers, Git peut déterminer son état en très peu de temps.

Nous avons dit plus tôt que l'index était une aire de rassemblement. Comment se peut-il qu'un simple fichier contant quelques informations sur les fichiers soit une aire de rassemblement ? Parce que la commande add ajoute les fichiers à la base de données de Git et met à jour l'index avec leurs informations alors que la commande commit, sans option, crée une nouvelle version basée uniquement sur cet index et les fichiers déjà inclus dans la base de données.

=== Les origines de Git ===

Ce http://lkml.org/lkml/2005/4/6/121[message de la Mailing List du noyau Linux] décrit l'enchaînement des évènements ayant mené à Git. L'ensemble de l'enfilade est un site archéologique fascinant pour les historiens de Git.

=== La base d'objets ===

Chacune des versions de vos données est conservée dans la base d'objets ('object database') qui réside dans le sous-répertoire `.git/objects` ; les autres parties de `.git` conservent moins de données : l'index, le nom des branches, les tags, les options de configuration, les logs, l'emplacement actuel de HEAD, et ainsi de suite. La base d'objets est simple mais élégante et constitue la source de la puissance de Git.

Chaque fichier dans `.git/objects` est un objet. Il y a trois sortes d'objets qui nous concerne : les `blobs`, les `trees` et les `commits`.

=== Les blobs ===

Tout d'abord, faisons un peu de magie. Choisissez un nom de fichier... n'importe quel nom de fichier. Puis dans un répertoire vide, faites (en remplaçant `VOTRE_NOM_DE_FICHIER` par le nom  que vous avez choisi) :

 $ echo joli > VOTRE_NOM_DE_FICHIER
 $ git init
 $ git add .
 $ find .git/objects -type f

Vous verrez +.git/objects/06/80f15d4cb13a09f600a25b84eae36506167970+.

Comment puis-je le savoir sans connaître le nom de fichier que vous avez choisi ? Tout simplement parce que le hash SHA1 de :

 "blob" SP "5" NUL "joli" LF

est 0680f15d4cb13a09f600a25b84eae36506167970. Où SP est un espace, NUL est l'octet de valeur nulle et LF est un passage à la ligne. Vous pouvez vérifier cela en tapant :

  $ printf "blob 5\000joli\n" | sha1sum

Git utilise un classement par contenu : les fichiers ne sont pas stockés selon leur nom mais selon le hash des données qu'ils contiennent, dans un fichier que nous appelons un objet 'blob'. Nous pouvons considérer le hash comme un ID unique du contenu d'un fichier. Donc nous pouvons retrouver un fichier par son contenu. La chaîne initiale `blob 5` est simplement un entête indiquant le type de l'objet et sa longueur en octets ;  cela simplifie le classement interne.

Je peux donc aisément prédire ce que vous voyez. Le nom du fichier ne compte pas : pour construire l'objet blob, seules comptent les données stockées dans le fichier.

Peut-être vous demandez-vous ce qui se produit pour des fichiers ayant le même contenu. Essayez en créant des copies de votre premier fichier, avec des noms quelconques. Le contenu de +.git/objects+ reste le même quel que soit le nombre de copies que vous avez ajoutées. Git ne stocke le contenu qu'une seule fois.

À propos, les fichiers dans +.git/objects+ sont compressés par zlib et, par conséquent, vous ne pouvez pas en consulter le contenu directement. Passez-les au travers du filtre http://www.zlib.net/zpipe.c[zpipe -d] ou tapez :

 $ git cat-file -p 0680f15d4cb13a09f600a25b84eae36506167970

qui affiche proprement l'objet choisi.

=== Les Trees ===

Mais où sont les noms des fichiers ? Ils doivent bien être stockés quelque part à un moment. Git se préoccupe des noms de fichiers lors d'un commit :

 $ git commit  # Tapez un message
 $ find .git/objects -type f

Vous devriez voir maintenant trois objets. Mais là, je ne peux plus prédire le nom des deux nouveaux fichiers puisqu'ils dépendent en partie du nom de fichier que vous avez choisi. Nous continuerons en supposant que vous avez choisi ``rose''. Si ce n'est pas le cas, vous pouvez réécrire l'histoire pour que ce soit le cas :

 $ git filter-branch --tree-filter 'mv VOTRE_NOM_DE_FICHIER rose'
 $ find .git/objects -type f

Maintenant vous devriez voir un fichier +.git/objects/9a/6a950c3b14eb1a3fb540a2749514a1cb81e206+ puisque c'est le hash SHA1 du contenur suivant 

Now you should see the file
+.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9+, because this is the
SHA1 hash of its contents:

 "tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d

Check this file does indeed contain the above by typing:

 $ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch

With zpipe, it's easy to verify the hash:

 $ zpipe -d < .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum

Hash verification is trickier via cat-file because its output contains more
than the raw uncompressed object file.

This file is a 'tree' object: a list of tuples consisting of a file
type, a filename, and a hash. In our example, the file type is 100644, which
means `rose` is a normal file, and the hash is the blob object that contains
the contents of `rose'. Other possible file types are executables, symlinks or
directories. In the last case, the hash points to a tree object.

If you ran filter-branch, you'll have old objects you no longer need. Although
they will be jettisoned automatically once the grace period expires, we'll
delete them now to make our toy example easier to follow:

 $ rm -r .git/refs/original
 $ git reflog expire --expire=now --all
 $ git prune

For real projects you should typically avoid commands like this, as you are
destroying backups. If you want a clean repository, it is usually best to make
a fresh clone. Also, take care when directly manipulating +.git+: what if a Git
command is running at the same time, or a sudden power outage occurs?
In general, refs should be deleted with *git update-ref -d*,
though usually it's safe to remove +refs/original+ by hand.

=== Commits ===

We've explained 2 of the 3 objects. The third is a 'commit' object. Its
contents depend on the commit message as well as the date and time it was
created. To match what we have here, we'll have to tweak it a little:

 $ git commit --amend -m Shakespeare  # Change the commit message.
 $ git filter-branch --env-filter 'export
     GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
     GIT_AUTHOR_NAME="Alice"
     GIT_AUTHOR_EMAIL="alice@example.com"
     GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
     GIT_COMMITTER_NAME="Bob"
     GIT_COMMITTER_EMAIL="bob@example.com"'  # Rig timestamps and authors.
 $ find .git/objects -type f

You should now see
+.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187+
which is the SHA1 hash of its contents:

 "commit 158" NUL
 "tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
 "author Alice <alice@example.com> 1234567890 -0800" LF
 "committer Bob <bob@example.com> 1234567890 -0800" LF
 LF
 "Shakespeare" LF

As before, you can run zpipe or cat-file to see for yourself.

This is the first commit, so there are no parent commits, but later commits
will always contain at least one line identifying a parent commit.

=== Indistinguishable From Magic ===

Git's secrets seem too simple. It looks like you could mix together a few shell scripts and add a dash of C code to cook it up in a matter of hours: a melange of basic filesystem operations and SHA1 hashing, garnished with lock files and fsyncs for robustness. In fact, this accurately describes the earliest versions of Git. Nonetheless, apart from ingenious packing tricks to save space, and ingenious indexing tricks to save time, we now know how Git deftly changes a filesystem into a database perfect for version control.

For example, if any file within the object database is corrupted by a disk
error, then its hash will no longer match, alerting us to the problem. By
hashing hashes of other objects, we maintain integrity at all levels. Commits
are atomic, that is, a commit can never only partially record changes: we can
only compute the hash of a commit and store it in the database after we already
have stored all relevant trees, blobs and parent commits. The object
database is immune to unexpected interruptions such as power outages.

We defeat even the most devious adversaries. Suppose somebody attempts to
stealthily modify the contents of a file in an ancient version of a project. To
keep the object database looking healthy, they must also change the hash of the
corresponding blob object since it's now a different string of bytes. This
means they'll have to change the hash of any tree object referencing the file,
and in turn change the hash of all commit objects involving such a tree, in
addition to the hashes of all the descendants of these commits. This implies the
hash of the official head differs to that of the bad repository. By
following the trail of mismatching hashes we can pinpoint the mutilated file,
as well as the commit where it was first corrupted.

In short, so long as the 20 bytes representing the last commit are safe,
it's impossible to tamper with a Git repository.

What about Git's famous features? Branching? Merging? Tags?
Mere details. The current head is kept in the file +.git/HEAD+,
which contains a hash of a commit object. The hash gets updated during a commit
as well as many other commands. Branches are almost the same: they are files in
+.git/refs/heads+. Tags too: they live in +.git/refs/tags+ but they
are updated by a different set of commands.
