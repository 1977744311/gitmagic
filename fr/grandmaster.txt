// -*- mode: doc; mode: visual-line; mode: flyspell; coding: utf-8; -*-
== La maîtrise de Git ==

À ce stade, vous devez être capable de parcourir les pages de *git help* et comprendre presque tout. En revanche, retrouver la commande exacte qui résoudra un problème précise peut être fastidieux. Je peux sans doute vous aider à gagner un peu de temps : vous trouverez ci-dessous quelques-unes des recettes dont j'ai déjà eu besoin.

=== Publication de sources ===

Dans mes projets, Git gère exactement tous les fichiers que je veux placer dans une archive afin de la publier. Pour créer une telle archive de codes source, j'utilise :

 $ git archive --format=tar --prefix=proj-1.2.3/ HEAD

=== Gérer le changement ===

Indiquer à Git quels fichiers ont été ajoutés, supprimés ou renommés est parfois pénible pour certains projets. À la place, vous pouvez faire :

 $ git add .
 $ git add -u

Git cherchera les fichiers du répertoire courant et gérera tous les détails tout seul. À la place de deuxième commande 'add', vous pouvez utiliser `git commit -a` créer une nouvelle version automatiquement. Lisez *git help ignore* pour savoir comment spécifier les fichiers qui doivent être ignorés.

Vous pouvez effectuer tout cela en une seule passe grâce à :

 $ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove

Les options *-z* et *-0* empêchent les effets secondaires imprévus dûs au noms de fichiers contenant des caractères étranges.  Comme cette commande ajoutent aussi les fichiers ignorés, vous voudrez sûrement utiliser les options `-x` ou `-X`.

=== Mon commit est trop gros ! ===

Avez-vous négligé depuis longtemps de faire un commit ? Avez-vous codé furieusement et tout oublié de la gestion de version jusqu'à présent ? Faites-vous plein de petits changements sans rapport entre eux parce que c'est votre manière de travailler ?

Pas de soucis. Faites :

 $ git add -p

Pour chacune des modifications que vous avez faites, Git vous montrera le bout de code qui a changé et vous demandera si elle doit faire partie du prochain commit. Répondez par "y" (oui) ou par "n" (non). Vous avez aussi d'autres options comme celle vous permettant de reporter votre décision ; tapez "?" pour en savoir plus.

Une fois satisfait, tapez :

 $ git commit

pour faire un commit incluant exactement les modifications qui vous avez sélectionnées (les modifications 'staged'). Soyez bien sûr de ne pas mettre l'option *-a* sinon Git fera un commit incluant toutes vos modifications.

Que faire si vous avez modifié de nombreux fichiers contiennent de nombreuses modifications ? Vérifier chaque modification individuellement devient alors rapidement frustrant et abrutissant. Dans ce cas, utilisez la commande *git add -i* dont l'interface est moins facile mais beaucoup plus souple. En quelques touches vous pouvez ajouter ou retirer de votre index (voir ci-dessous) plusieurs fichiers d'un seul coup mais aussi valider ou non chacune des modifications individuellement pour certains fichiers. Vous pouvez aussi utilisez en remplacement la commande *git commit \--interactive* qui effectuera un commit automatiquement quand vous aurez terminé.

=== L'index : l'aire de rassemblement (_stage_) de Git ===

Jusqu'ici nous avons réussi à éviter de parler du fameux 'index' de Git mais nous devons maintenant le présenter pour mieux comprendre ce qui précède. L'index est une aire de rassemblement temporaire. Git ne transfert que très rarement de données depuis votre répertoire de travail directement vers votre historique. En fait, Git copie d'abord ces données dans l'index puis il copie toutes ces données depuis l'index vers leur destination finale.

Un *commit -a*, par exemple, est en fait un processus en deux temps. La première étape consiste à construire dans l'index un instantané de l'état actuel de tous les fichiers suivis par Git. La seconde étape enregistre cet instantané de manière permanente dans l'historique. Effectuer un commit sans l'option *-a* réalise uniquement cette deuxième étape et cela n'a de sens qu'après avoir effectuer des commandes qui change l'index, telle que *git add*.

Habituellement nous pouvons ignorer l'index et faire comme si nous échangions directement avec l'historique. Dans certaines occasions, nous voulons un contrôle fin et nous gérons donc l'index. Nous plaçons dans l'index un instantané de certaines modifications (mais pas toutes) et enregistrons de manière permanente cet instantané soigneusement construit.

=== Ne perdez pas la tête (_HEAD_) ===

Le tag HEAD est comme un curseur qui pointe habituellement vers le tout dernier commit et qui avance à chaque commit. Certaines commandes Git vous permettent de le déplacer. Par exemple :

 $ git reset HEAD~3

déplacera HEAD trois commits en arrière. À partir de là, toutes les commandes Git agiront comme si vous n'aviez jamais fait ces trois commits, même si vos fichier restent dans leur état présent. Voir les pages d'aide pour quelques usages intéressants.

Mais comment faire pour revenir vers le futur ? Les commits passés ne savent rien du futur.

Si vous connaissez le SHA1 du HEAD original, faites alors :

 $ git reset 1b6d

Mais que faire si vous ne l'avez pas regardé ? Pas de panique : pour des commandes comme celle-ci, Git enregistre la valeur originale de HEAD dans un tag nommé ORIG_HEAD et vous pouvez revenir sain et sauf via :

 $ git reset ORIG_HEAD

=== Chasseur de tête ===

Peut-être que ORIG_HEAD ne vous suffit pas. Peut-être venez-vous de vous apercevoir que vous avez fait une monumentale erreur et que vous devez revenir à une ancienne version d'une branche oubliée depuis longtemps.

Par défaut, Git conserve un commit au moins deux semaine même si vous avez demandé à Git de détruire la branche qui le contient. La difficulté consiste à retrouver le hash approprié. Vous pouvez toujours explorer les différentes valeurs de hash trouvées dans `.git/objects` et retrouver celle que vous cherchez par essai et erreur. Mais il existe un moyen plus simple.

Git enregistre le hash de chaque commit qu'il traite dans `.git/logs`. La sous-répertoire `refs` contient l'historique de toute l'activité de chaque branche alors que le fichier `HEAD` montre chaque valeur de hash que HEAD a pu prendre. Ce dernier peut donc servir à retrouver les commits d'une branche qui a été accidentellement élaguée.

La commande reflog propose une interface sympa vers ces fichiers de log. Essayez: 

  $ git reflog

Au lieu de copier/coller un hash listé par reflog, essayez :

 $ git checkout "@{10 minutes ago}"

Ou basculez vers le cinquième précédent commit visité via :

 $ git checkout "@{5}"

Voir la section ``Specifying Revisions'' de *git help rev-parse* pour en savoir plus.

Vous pouvez configurer une plus longue période de grâce pour les commits condamnés. Par exemple :

  $ git config gc.pruneexpire "30 days"

signifie qu'un commit effacé ne le sera véritablement qu'après 30 jours et lorsque $git gc* tournera.

Vous pouvez aussi désactiver le déclenchement automatique de *git gc* :

  $ git config gc.auto 0

auquel cas les commits ne seront véritablement effacés que lorsque vous lancerez *git run* manuellement.

=== Construire au-dessus de Git ===

À la manière d'UNIX, la conception de Git permet son utilisation comme un composant de bas niveau d'autres programmes tels que des interfaces graphiques ou web, des interfaces en ligne de commandes alternatives, des outils de gestion de patch, des outils d'importation et de conversion, etc. En fait, certaines commandes Git sont de simples scripts s'appuyant sur les commandes de base, comme des nains sur des épaules de géants. Avec un peu de bricolage, vous pouvez adapter Git à vos préférences.

Une astuce facile consiste à créer des alias Git pour raccourcir les commandes que vous utilisez le plus fréquemment :

  $ git config --global alias.co checkout
  $ git config --global --get-regexp alias  # affiche les alias connus
  alias.co checkout
  $ git co foo                              # identique à 'git checkout foo'

Une autre astuce consiste à intégrer le nom de la branche courant dans votre prompt ou dans le titre de la fenêtre. L'invocation de :

  $ git symbolic-ref HEAD

montre le nom complet de la branche courante. En pratique, vous souhaiterez probablement enlever "refs/heads/" et ignorer les erreurs :

  $ git symbolic-ref HEAD 2> /dev/null | cut -b 12-

Le sous-répertoire +contrib+ est une mine d'outils construits par dessus Git. Un jour, certains d'entre eux pourraient être promus au rang de commandes officielles. Dans Debian et Ubuntu, ce répertoire est  +/usr/share/doc/git-core/contrib+.

L'un des plus populaires de ces scripts est +workdir/git-new-workdir+. Grâce 
à des liens symboliques intelligents, ce script crée un nouveau dépôt dont l'historique est partagé avec le dépôt original.

  $ git-new-workdir un/existant/depot nouveau/repertoire

Le nouveau répertoire et ses fichiers peut être vu comme un clone, sauf que l'historique est partagé et que les deux arbres des versions reste automatiquement synchrones. Nul besoin de merge, push ou pull.

=== Audacieuses acrobaties  ===

À ce jour, Git fait tout son possible pour que l'utilisateur ne puisse pas effacer accidentellement des données. Mais si vous savez ce que vous faites, vous pouvez passer outre les garde-fous des principales commandes.


*Checkout*: Uncommitted changes cause checkout to fail. To destroy your changes, and checkout a given commit anyway, use the force flag:

  $ git checkout -f HEAD^

On the other hand, if you specify particular paths for checkout, then there are no safety checks. The supplied paths are quietly overwritten. Take care if you use checkout in this manner.

*Reset*: Reset also fails in the presence of uncommitted changes. To force it through, run:

  $ git reset --hard 1b6d

*Branch*: Deleting branches fails if this causes changes to be lost. To force a deletion, type:

  $ git branch -D dead_branch  # instead of -d

Similarly, attempting to overwrite a branch via a move fails if data loss would ensue. To force a branch move, type:

  $ git branch -M source target  # instead of -m

Unlike checkout and reset, these two commands defer data destruction. The
changes are still stored in the .git subdirectory, and can be retrieved by
recovering the appropriate hash from `.git/logs` (see "HEAD-hunting" above).
By default, they will be kept for at least two weeks.

*Clean*: Some git commands refuse to proceed because they're worried about
clobbering untracked files. If you're certain that all untracked files and
directories are expendable, then delete them mercilessly with:

  $ git clean -f -d

Next time, that pesky command will work!

=== Preventing Bad Commits ===

Stupid mistakes pollute my repositories. Most frightening are missing files due
to a forgotten *git add*. Lesser transgressions are trailing whitespace and
unresolved merge conflicts: though harmless, I wish these never appeared on the
public record.

If only I had bought idiot insurance by using a _hook_ to alert me about these problems:

 $ cd .git/hooks
 $ cp pre-commit.sample pre-commit  # Older Git versions: chmod +x pre-commit

Now Git aborts a commit if useless whitespace or unresolved merge conflicts are
detected.

For this guide, I eventually added the following to the beginning of the
*pre-commit* hook to guard against absent-mindedness:

 if git ls-files -o | grep '\.txt$'; then
   echo FAIL! Untracked .txt files.
   exit 1
 fi

Several git operations support hooks; see *git help hooks*. We activated the
sample *post-update* hook earlier when discussing Git over HTTP. This runs
whenever the head moves. The sample post-update script updates files Git needs
for communication over Git-agnostic transports such as HTTP.
