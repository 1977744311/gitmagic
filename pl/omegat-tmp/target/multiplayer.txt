== Multiplayer Git ==

Na początku zastosowałem git przy prywatnym projekcie, gdzie byłem jedynym developerem. Z poleceń w związku z rozproszoną naturą git, potrzebowałem jedynie poleceń *pull* i *clone*, dzięki czemu mogłem trzymać ten sam projekt w kilku miejscach.

Później chciałem opublikować mój kod za pomocą git i dołączyć zmiany kolegów Musiałem nauczyć się zarządzać projektami, nad którymi zaangażowani byli programiści z całego świata. Na szczęście jest to silną stroną git i chyba jego racją bytu.

=== Kim jestem? ===

Każdy 'commit' otrzymuje nazwę i adres email autora, które zostaną pokazane w *git log*. Standardowo git korzysta z ustawień systemowych do wypełnienia tych pól. Aby wprowadzić te dane bezpośrednio, podaj:

$ git config --global user.name "Jan Kowalski" $ git config --global user.email jan.kowalski@example.com

Jeśli opóścisz przełącznik '--global' zmiany zostaną zastosowane wyłącznie do aktualnego repozytorium.

=== Git przez SSH, HTTP ===

Załóżmy, posiadasz dostęp SSH do serwera stron internetowych, gdzie jednak git nie został zainstalowany. Nawet, jeśli jest to mniej efektywne jak własny protokół git, git potrafi komunikować się przez HTTP.

Zładuj git, skompiluj i zainstaluj pod własnym kontem oraz utwórz repozytorium w twoim katalogu strony internetowej.

$ GIT_DIR=proj.git git init $ cd proj.git $ git --bare update-server-info $ cp hooks/post-update.sample hooks/post-update 

Przy starszych wersjach git samo polecenie 'cp' nie będzie funkcjonować, wtedy musisz jeszcze:

chmod a+x hooks/post-update 

Od teraz możesz publikować aktualizacje z każdego klonu poprzez SSH.

$ git push web.server:/sciezka/do/proj.git master 

i każdy może teraz sklonować twój projekt przez:

$ git clone http://web.server/proj.git 

=== Git ponad wszystko ===

Chciałbyś synchronizować repozytoria bez pomocy serwera czy nawet bez użycia sieci komputerowej? Musisz improwizować w nagłym wypadku? Widzieliśmym, że poleceniami <<makinghistory, *git fast-export* i *git fast-import* możemy konwertować całe repozytoria w jeden jedyny plik i spowrotem>>. W ten sposób możemy transportować tego typu pliki za pomocą dowolnego medium, jednak bardziej wydajnym narzędziem jest *git bundle*. 

Nadawca tworzy 'bundle':

$ git bundle create plik HEAD

i transportuje 'bundle' +plik+ do innych zaangażowanych: przez email, stik-usb, *xxd* hexdump i skaner OCR, kod morse przez telefon, znaki dymne itd. Odbiorca wyciąga 'commits' z 'bundle' poprzez podanie:


$ git pull plik

Odbiorca może to zrobić z pustym repozytorium. Mimo swojej wielkości +plik+ zawiera kompletny orginał repozytorium.

W dużych projektach unikniesz śmieci danych, jeśli tylko zrobisz 'bundle' zmian brakujących w innych repozytoriach. Na przykład załóżmy, że 'commit' ``1b6d...'' jest najaktualniejszym, które posiadają obie partie:


$ git bundle create plik HEAD ^1b6d

Jeśli robi się to regularnie, łatwo można zapomnieć, który 'commit' został wysłany ostatnio. Strony pomocy zalecają stosowanie tagów, by rozwiązać ten problem. To znaczy, po wysłaniu 'bundle', podaj:

$ git tag -f ostatnibundle HEAD

a nowy 'bundle' tworzymy następnie poprzez:

$ git bundle create nowybundle HEAD ^ostatnibundle

=== Patches: globalny środek płatniczy ===

'Patches' to jawne zobrazowanie twoich zmian, które mogą być jednocześnie rozumiane przez komputer i człowieka. Dodaje im to uniwersalnej mocy przyciągania. Możesz wysłać patch prowadzącym projekt, niezależnie od tego, jakiego używają systemu kontroli wersji. Doputy twoi współpracownicy potrafią czytać swoje maile, mogą widzieć również twoje zmiany. Również i z twojej strony wszystko, czego ci potrzeba to fukcjonujące konto mailowe: nie istnieje konieczność zakładania repozytorium online.

Przypomnij sobie pierwszy rozdział:

$ git diff 1b6d > moj.patch

produkuje 'patch', który można dołączyć do maila dla dalszej dyskusji. W repozytorium git natomiast podajesz:

$ git apply < moj.patch

By zastosować patch.

W bardziej oficjalnym środowisku, jeśli nawiska autorów i ich sygnatury powinny również być notowane, tworz 'patch' od pewnego punktu, po wpisaniu:

git format-patch 1b6d 

Uzyskane w ten sposób dane mogą przekazane być do *git-send-mail* albo odręcznie wysłane. Możesz podać grupę 'commits'

$ git format-patch 1b6d..HEAD^^ 

Po stronie odbiorcy zapamiętaj email jako daną i podaj:

$ git am < email.txt 

Das wendet den eingegangenen 'Patch' an und erzeugt einen 'Commit', inklusive der Informationen wie z.B. den Autor.

Mit einer Webmail Anwendung musst Du eventuell ein Button anklicken um die eMail in ihrem rohen Originalformat anzuzeigen, bevor Du den 'Patch' in eine Datei sicherst.

Es gibt geringfügige Unterschiede bei mbox-basierten eMail Anwendungen, aber wenn Du eine davon benutzt, gehörst Du vermutlich zu der Gruppe Personen, die damit einfach umgehen können ohne Anleitungen zu lesen.!

=== Entschuldigung, wir sind umgezogen. ===

Nach dem 'Clonen' eines 'Repositories', wird *git push* oder *git pull* automatisch auf die original URL zugreifen. Wie macht Git das? Das Geheimnis liegt in der Konfiguration, die beim 'Clonen' erzeugt wurde. Lasst uns einen Blick riskieren:

$ git config --list

Die +remote.origin.url+ Option kontrolliert die Quell-URL; ``origin'' ist der Spitzname, der dem Quell-'Repository' gegeben wurde. Wie mit der ``master'' 'Branch' Konvention können wir diesen Spitznamen ändern oder löschen, aber es gibt für gewöhnlich keinen Grund dies zu tun.

Wenn das original 'Repository' verschoben wird, können wir die URL aktualisieren mit:

$ git config remote.origin.url git://neue.url/proj.git

Die +branch.master.merge+ Option definiert den Standard-Remote-'Branch' bei einem *git pull*. Während dem ursprünglichen 'clonen', wird sie auf den aktuellen 'Branch' des Quell-'Repository' gesetzt, so dass selbst dann, wenn der 'HEAD' des Quell-'Repository' inzwischen auf einen anderen 'Branch' gewechselt hat, ein späterer 'pull' wird treu dem original 'Branch' folgen.

Diese Option gilt nur für das 'Repository', von dem als erstes 'gecloned' wurde, was in der Option +branch.master.remote+ hinterlegt ist. Bei einem 'pull' aus anderen 'Repositories' müssen wir explizit angeben, welchen 'Branch' wir wollen:

$ git pull git://beispiel.com/anderes.git master

Das obige erklärt, warum einige von unseren früheren 'push' und 'pull' Beispielen keine Argumente hatten.

=== Entfernte 'Branches' ===

Wenn Du ein 'Repository' 'clonst', 'clonst' Du auch alle seine 'Branches'. Das hast Du vielleicht noch nicht bemerkt, denn Git versteckt diese: Du musst speziell danach fragen. Das verhindert, dass 'Branches' vom entfernten 'Repository' Deine lokalen 'Branches' stören und es macht Git einfacher für Anfänger.

Zeige die entfernten 'Branches' an mit:

$ git branch -r

Du solltes etwas sehen wie:

origin/HEAD origin/master origin/experimentell

Diese Liste zeigt die 'Branches' und den HEAD des entfernten 'Repository', welche auch in regulären Git Anweisungen verwendet werden können. Zum Beispiel, angenommen Du hast viele 'Commits' gemacht und möchtest einen Vergleich zur letzten abgeholten Version machen. Du kannst die Logs nach dem entsprechenden SHA1 Hashwert durchsuchen, aber es ist viel einfacher folgendes einzugeben:

$ git diff origin/HEAD

Oder Du kannst schauen, was auf dem 'Branch' ``experimentell'' los war:

$ git log origin/experimentell

=== Mehrere 'Remotes' ===

Angenommen, zwei andere Entwickler arbeiten an Deinem Projekt und wir wollen beide im Auge behalten. Wir können mehr als ein 'Repository' gleichzeitig beobachten mit:

$ git remote add other git://example.com/some_repo.git $ git pull other some_branch

Nun haben wir einen 'Branch' vom zweiten 'Repository' eingebunden und wir haben einfachen Zugriff auf alle 'Branches' von allen 'Repositories':

$ git diff origin/experimentell^ other/some_branch~5

Aber was, wenn wir nur deren Änderungen vergleichen wollen, ohne unsere eigene Arbeit zu beeinflussen? Mit anderen Worten, wir wollen ihre 'Branches' untersuchen ohne dass deren Änderungen in unser Arbeitsverzeichnis einfließen. Anstatt 'pull' benutzt Du dann:

$ git fetch # Fetch vom origin, der Standard. $ git fetch other # Fetch vom zweiten Programmierer.

Dies holt lediglich die Chroniken. Obwohl das Arbeitsverzeichnis unverändert bleibt, können wir nun jeden 'Branch' aus jedem 'Repository' in einer Git Anweisung referenzieren, da wir eine lokale Kopie besitzen.

Erinnere Dich, dass ein 'Pull' hinter den Kulissen einfach ein *fetch* gefolgt von einem *merge* ist. Normalerweise machen wir einen *pull* weil wir die letzten 'Commits' abrufen und einbinden wollen. Die beschriebene Situation ist eine erwähnenswerte Ausnahme.

Siehe *git help remote* um zu sehen wie man Remote-'Repositories' entfernt, bestimmte 'Branches' ignoriert und mehr.

=== Meine Einstellungen ===

Für meine Projekte bevorzuge ich es, wenn Unterstützer 'Repositories' vorbereiten, von denen ich 'pullen' kann. Verschiedene Git Hosting Anbieter lassen Dich mit einem Klick deine eigene 'Fork' eines Projekts hosten.

Nachdem ich einen Zweig abgerufen habe, benutze ich Git Anweisungen um durch die Änderungen zu navigieren und zu untersuchen, die idealerweise gut organisiert und dokumentiert sind. Ich 'merge' meine eigenen Änderungen und führe eventuell weitere Änderungen durch. Wenn ich zufrieden bin, 'pushe' ich in das zentrale 'Repository'.

Obwohl ich nur unregelmäßig Beiträge erhalte, glaube ich, dass diese Methode sich auszahlt. Siehe http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html[diesen Blog Beitrag von Linus Torvalds (englisch)].

In der Git Welt zu bleiben ist etwas bequemer als 'Patch'-Dateien, denn es erspart mir sie in Git 'Commits' zu konvertieren. Außerdem kümmert sich Git um die Details wie Autorname und eMail-Adresse, genauso wie um Datum und Uhrzeit und es fordert den Autor zum Beschreiben seiner eigenen Änderungen auf.