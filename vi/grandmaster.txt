== Git Grandmastery ==

Bây giờ, bạn có thể thông qua lệnh *git help* để bật trang trợ giúp lên và có thể hiểu
gần như tất cả mọi thứ. Tuy nhiên, việc xác định chính xác lệnh cần sử dụng để giải quyết
các vấn đề đặt ra có lẽ chẳng dễ dàng gì. Có thể tôi có thể giúp bạn tiết kiệm được thời gian: bên dưới là một vài
cách giải quyết các vấn đề thực tế đặt ra mà tôi đã từng sử dụng trong quá khứ.

=== Phát hành Mã Nguồn ===

Với dự án của tôi, Git giữ theo dõi chính xác các tệp tin tôi muốn lưu trữ và phát hành tới
người dùng. Để tạo gói tarball cho mã nguồn, tôi chạy:

 $ git archive --format=tar --prefix=proj-1.2.3/ HEAD

=== Commit What Changed ===

Việc phải thông báo với Git khi bạn thêm, xóa hay đổi tên các tệp tin là việc rầy rà với
các dự án nào đó. Thay vào đó, bạn có thể gõ:

 $ git add .
 $ git add -u

Git sẽ xem tất cả các tệp tin trong thư mục hiện tại và làm công việc mà nó phải
làm. Thay vì chạy lệnh add thứ hai, hãy chạy  `git commit -a` nếu bạn cũng có
ý định commit vào lúc này. Xem *git help ignore* để biết làm cách nào để chỉ ra
các tệp tin bỏ qua.

Bạn có thể thi hành những điều trên chỉ cần một dòng lệnh:

 $ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove

Tùy chọn *-z* và *-0* dùng để ngăn ngừa sai hỏng không mong muốn từ những tệp tin có chứa
các ký tự đặc biệt. As this command adds ignored files, bạn có thể muốn sử dụng
tùy chọn `-x` hay `-X`.

=== Lần commit này Nhiều Quá! ===

Bạn quên việc commit quá lâu? Bạn quá mải mê với việc viết mã nguồn mà quên đi
việc quản lý nó? Bạn muốn những thay đổi liên quan đến nhau phải được commit riêng từng lần và nối tiếp nhau, bởi vì
đây là phong cách của bạn?

Đừng lo lắng. Chạy:

 $ git add -p

Với mỗi lần thay đổi mà bạn tạo ra, Git sẽ hiện cho bạn biết từng đoạn mã đã bị thay đổi,
và hỏi nó có phải là một bộ phận của lần commit tiếp theo. Trả lời là  "y" hay "n". Bạn
có các sự lựa chọn khác, như là hoãn lại; gõ "?" để biết thêm chi tiết.

Khi nào bạn thỏa mãn thì gõ

 $ git commit

để commit chính xác các thay đổi mà bạn đã chọn lựa (the 'staged' changes). Hãy chắc chắn là
bạn đã không dùng tùy chọn *-a*, nếu không thì Git sẽ commit tất cả.

Nhưng bạn lại có những tài liệu đã được chỉnh sửa đặt tại nhiều chỗ khác nhau? Duyệt từng cái một
trở nên frustratingly mind-numbing. Trong trường hợp này, sử dụng lệnh *git add -i*, whose
interface is less straightforward, nhưng uyển chuyển hơn. With a few keystrokes,
you can stage or unstage several files at a time, or review and select changes
chỉ trong các tệp tin riêng biệt. Có một sự lựa chọn khác, chạy lệnh *git commit \--interactive* which
automatically commit sau khi bạn làm xong.

=== The Index: Git's Staging Area ===

So far we have avoided Git's famous 'index', nhưng chúng ta phải đối mặt it to
explain the above. Chỉ mục là vùng trạng thái tạm thời. Git ít khi shuttles
data directly between your project and its history. Đúng hơn là Git đầu tiên ghi
dữ liệu vào chỉ mục, và sau đó sao chép dữ liệu trong chỉ mục vào chỗ cần ghi
cuối.

Ví dụ, lệnh *commit -a* thực sự bao gồm hai quá trình. Bước thứ nhất là đặt
snapshot of the current state of every tracked file vào chỉ mục (index). Bước thứ
hai là permanently records the snapshot now in the index. Việc commit không sử dụng tùy chọn
*-a* chỉ thi hành bước thứ hai, and only makes sense after running
commands that somehow change the index, như là lệnh *git add*.

Usually we can ignore the index and pretend we are reading straight from and ghi thẳng vào trong lịch sử. On this occasion, we want finer control, so we manipulate the index. We place a snapshot of some, không phải tất cả, các thay đổi của chúng ta vào chỉ mục, and then permanently record this carefully rigged snapshot.

=== Đừng Quên HEAD của Mình ===

Thẻ HEAD giống như một con trỏ, nó trỏ đến lần commit cuối cùng, tự động di chuyển theo mỗi lần commit mới. Một số lệnh của Git giúp bạn di chuyển nó. Ví dụ như:

 $ git reset HEAD~3

sẽ chuyển HEAD lên vị trí lần commit cách đây ba lần. Thế thì tất cả các lệnh Git thi hành như khi bạn ở vị trí commit này, trong khi các tệp tin của bạn vẫn nằm ở hiện tại. Xem thêm phần trợ giúp cho một số ứng dụng.

Nhưng ta lại muốn quay trở lại phần sau này? Lần commit cũ không biết gì về phần sau này cả.

Nếu bạn có giá trị băm SHA1 của HEAD gốc thì:

 $ git reset 1b6d

Nhưng giả sử bạn không có được nó? Đừng lo: với những lệnh như thế, Git ghi lại HEAD gốc với thẻ có tên là ORIG_HEAD, và bạn có thể trở về ngon lành và an toàn với lệnh:

 $ git reset ORIG_HEAD

=== Săn tìm-HEAD ===

Có thể ORIG_HEAD là chưa đủ. Có lẽ you've just realized you made a monumental mistake and you need to go back to an ancient commit in a long-forgotten branch.

Theo mặc định, Git giữ một lần commit ít nhất là hai tuần lễ, ngay cả khi bạn đã ra lệnh
cho Git phá hủy nhánh chứa nó. Sự trục trặc là việc tìm giá trị băm
thích hợp. Bạn có thể tìm kiếm tất cả các giá trị băm trong `.git/objects` và sử dụng cách thử tất cả các giá trị
để có được thứ mình muốn. Nhưng còn có cách dễ dàng hơn.

Git ghi lại mọi giá trị băm của mọi lần commit trong máy tính tại thư mục `.git/logs`. Thư mục con `refs` chứa lịch sử của tất cả các hoạt động trên tất cả cách nhánh, trong khi tệp tin `HEAD` giữ tất cả các giá trị băm mà nó từng có được. Phần sau có thể được sử dụng để tìm kiếm giá trị băm của các lần commits trên các nhánh cái mà đã bị cắt đi một cách tình cờ.

Lệnh reflog cung cấp cho chúng ta một giao diện thân thiện dành cho các tệp tin log. Bạn có thể thử bằng lệnh:

  $ git reflog

Thay vì phải cắt và dán giá trị băm từ reflog, hãy thử:

 $ git checkout "@{10 minutes ago}"

Hay checkout lần thứ 5th-last visited commit thông qua lệnh:

 $ git checkout "@{5}"

Xem chương ``Specifying Revisions'' từ lệnh *git help rev-parse* để biết thêm chi tiết.

Bạn muốn cấu hình thời gian gia hạn lâu hơn việc xóa bỏ những lần commit. Ví
dụ:

  $ git config gc.pruneexpire "30 days"

có nghĩa là việc xóa một lần commit sẽ chỉ thực sự xảy ra khi 30 ngày đã qua và
lệnh *git gc* được gọi.

Bạn cũng có thể không cho phép chạy lệnh *git gc* một cách tự động:

  $ git config gc.auto 0

trong trường hợp này những lần commit sẽ chỉ bị xóa bỏ khi bạn chạy lệnh *git gc*.

=== Building On Git ===

In true UNIX fashion, Git được thiết kế cho phép nó dễ dàng được sử dụng như là một thành phần bên dưới của các chương trình khác, như là cho giao diện đồ họa GUI và giao diện Web để thay thế cho giao diện dòng lệnh, công cụ quản lý các miếng vá, các công cụ nhập và chuyển đổi, và những thứ tương tự như thế. Trên thực tế, một số lệnh Git bản chất nó cũng là các kịch bản (scripts) đứng trên vai của những người khổng lồ, chính là hệ điều hành. Chỉ cần sửa đổi một chút, bạn có thể bắt Git làm việc phù hợp với sở thích của mình.

Một mẹo nhỏ là sử dụng một built-in của Git là gán bí danh cho các lệnh để nó trở nên ngắn gọn hơn
sử dụng lệnh:

  $ git config --global alias.co checkout  #gán bí danh cho lệnh checkout là co
  $ git config --global --get-regexp alias  # hiển thị bí danh hiện hành
  alias.co checkout
  $ git co foo                              # có kết quả giống như chạy lệnh 'git checkout foo'

Một thứ khác là hiển thị nhánh hiện hành lên màn hình hay thanh tiêu đề của cửa sổ.
Gọi lệnh

  $ git symbolic-ref HEAD

sẽ hiển thị tên của nhánh hiện hành. Trong thực tiễn, you thích hợp nhất mốn gỡ bỏ want to remove
the "refs/heads/" và tránh errors:

  $ git symbolic-ref HEAD 2> /dev/null | cut -b 12-

Thư mục con +contrib+ là một kho báu được tìm thấy trong số các công cụ được xây dựng dành cho Git.
Đúng lúc, một số trong số chúng có thể được xúc tiến thành lệnh chính thức. Trên hệ thống Debian và
Ubuntu, thư mục này ở tại +/usr/share/doc/git-core/contrib+.

One popular resident is +workdir/git-new-workdir+. Via clever symlinking, this script creates a new working directory whose history is shared with the original repository:

  $ git-new-workdir an/existing/repo new/directory

Thư mục mới và các tệp tin trong nó có thể được coi như một bản sao, except since the history is shared, the two trees automatically ở tại sync. Ở đây không cần có sự trộn, push, hay pull.

=== Daring Stunts ===

These days, Git makes it difficult for the user to accidentally phá hủy dữ liệu.
Nhưng nếu như bạn biết mình đang làm gì, you can override safeguards for các lệnh
thông thường.

*Checkout*: Uncommitted changes cause checkout to fail. Để phá hủy sự thay đổi của mình, và dẫu sao cũng checkout commit đã cho, sử dụng cờ bắt buộc (force):

  $ git checkout -f HEAD^

Mặt khác, nếu bạn chỉ định rõ một đường dẫn chi tiết cho lệnh, thế thì ở đây không có sự kiểm tra an toàn nào cả. Đường dẫn được áp dụng sẽ bị âm thầm ghi đè lên. Hãy cẩn thận nếu bạn sử dụng lệnh checkout theo cách này.

*Reset*: Reset also fails in the presence of uncommitted changes. To force it through, run:

  $ git reset --hard 1b6d

*Branch*: Việc xóa các nhánh Deleting branches fails if this causes changes to be lost. Để ép buộc việc xóa, hãy gõ:

  $ git branch -D dead_branch  #thay vì sử dụng tùy chọn -d

Cũng tương tự như thế, việc cố gắng ghi đè lên một nhánh bằng cách a move fails if data loss would ensue. To force a branch move, type:

  $ git branch -M source target  # thay vì sử dụng tùy chọn -m

Không giống như checkout và reset, hai lệnh trên trì hoãn việc phá hủy dữ liệu. Các
thay đổi vẫn còn lưu giữ trong thư mục con .git, và có thể lấy lại được bằng cách
lấy giá trị băm `.git/logs` thích hợp (xem phần "Săn tìm - HEAD" ở phía trên).
Theo mặc định, chúng sẽ giữ ít nhất là hai tuần lễ.

*Clean*: Một số lệnh Git từ chối thi hành bởi vì chúng lo lắng về việc làm như thế
làm mất dấu hoàn toàn các tệp tin. Nếu bạn chắc chắn về tất cả các tệp tin và thư mục không cần Git
theo dõi nữa và muốn phá hủy chúng đi, thế thì xóa chúng triệt để với lệnh:

  $ git clean -f -d

Sau này, lệnh rầy rà đó sẽ hoạt động!

=== Ngăn Ngừa Commit Sai ===

Có một số lỗi ngớ ngẩn đã xảy ra với tôi. Điều tồi tệ nhất là để sót các tệp tin bởi vì
quên lệnh *git add*. Ít tệ hại hơn là các ký tự khoảng trắng và
những xung đột không cần phải trộn: mặc dù cũng chẳng tệ hại lắm, tôi mong rằng những điều này sẽ không xảy ra
với mọi người.

If only I had bought idiot insurance bằng cách sử dụng một _hook_ để cảnh báo người dùng khi có những vấn đề:

 $ cd .git/hooks
 $ cp pre-commit.sample pre-commit  # Older Git versions: chmod +x pre-commit

Ngày nay Git sẽ không commit nếu khi nó trộn nó chỉ tìm thấy những khoảng trắng vô ích hay
những xung đột không cần giải trộn.

Với bản hướng dẫn này, Tôi cuối cùng đã thêm vào dòng đầu của
hook *pre-commit* để đề phòng khi ta lơ đãng:

 if git ls-files -o | grep '\.txt$'; then
   echo FAIL! Untracked .txt files.
   exit 1
 fi

Nhiều hoạt động của Git hỗ trợ hooks; hãy xem *git help hooks*. Chúng tôi đã kích hoạt
một hook mẫu là *post-update* trước earlier khi nói đến Git thông qua HTTP. Cái này chạy
mỗi khi head di chuyển. Đoạn script ví dụ post-update cập nhật các tệp tin Git cần
cho việc truyền thông thông qua Git-agnostic chuyên chở bằng giao thức giống như là HTTP.
