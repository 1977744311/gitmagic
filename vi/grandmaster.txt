== Git Grandmastery ==

Bây giờ, bạn có thể thông qua lệnh *git help* để bật trang trợ giúp lên và có thể hiểu
gần như tất cả mọi thứ. Tuy nhiên, việc xác định chính xác lệnh cần sử dụng để giải quyết
các vấn đề đặt ra có lẽ chẳng dễ dàng gì. Có lẽ tôi có thể giúp bạn tiết kiệm được thời gian: bên dưới là một vài
chiêu mà tôi đã từng sử dụng trong quá khứ.

=== Phát hành Mã Nguồn ===

Với dự án của tôi, Git giữ theo dõi chính xác các tệp tin tôi muốn lưu trữ và phát hành tới
người dùng. Để tạo gói tarball cho mã nguồn, tôi chạy:

 $ git archive --format=tar --prefix=proj-1.2.3/ HEAD

=== Commit What Changed ===

Việc phải thông báo với Git khi bạn thêm, xóa hay đổi tên các tệp tin là việc rầy rà với
các dự án nào đó. Thay vào đó, bạn có thể gõ:

 $ git add .
 $ git add -u

Git sẽ xem tất cả các tệp tin trong thư mục hiện tại và làm công việc mà nó phải
làm. Thay vì chạy lệnh add thứ hai, hãy chạy  `git commit -a` nếu bạn cũng có
ý định commit vào lúc này. Xem *git help ignore* để biết làm cách nào để chỉ ra
các tệp tin bỏ qua.

Bạn có thể thi hành những điều trên chỉ cần một dòng lệnh:

 $ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove

Tùy chọn *-z* và *-0*  prevent ill side-effects từ những tệp tin có chứa
các ký tự đặc biệt. As this command adds ignored files, bạn có thể muốn sử dụng
tùy chọn `-x` hay `-X`.

=== Lần commit này Nhiều Quá! ===

Bạn quên việc commit quá lâu? Bạn quá mải mê với việc viết mã nguồn mà quên đi
việc quản lý nó? Bạn muốn những thay đổi liên quan đến nhau phải được commit riêng từng lần và nối tiếp nhau, bởi vì
đây là phong cách của bạn?

Đừng lo lắng. Chạy:

 $ git add -p

Với mỗi lần thay đổi mà bạn tạo ra, Git sẽ hiện cho bạn biết từng đoạn mã đã bị thay đổi,
và hỏi nó có phải là một bộ phận của lần commit tiếp theo. Trả lời là  "y" hay "n". Bạn
có các sự lựa chọn khác, như là hoãn lại; gõ "?" để biết thêm chi tiết.

Khi nào bạn thỏa mãn thì gõ

 $ git commit

để commit chính xác các thay đổi mà bạn đã chọn lựa (the 'staged' changes). Hãy chắc chắn là
bạn đã không dùng tùy chọn *-a*, nếu không thì Git sẽ commit tất cả.

Nhưng bạn lại có những tài liệu đã được chỉnh sửa đặt tại nhiều chỗ khác nhau? Duyệt từng cái một
becomes frustratingly mind-numbing. Trong trường hợp này, sử dụng lệnh *git add -i*, whose
interface is less straightforward, nhưng uyển chuyển hơn. With a few keystrokes,
you can stage or unstage several files at a time, or review and select changes
in particular files only. Có một sự lựa chọn khác, chạy lệnh *git commit \--interactive* which
automatically commits after you're done.

=== The Index: Git's Staging Area ===

So far we have avoided Git's famous 'index', but we must now confront it to
explain the above. The index is a temporary staging area. Git seldom shuttles
data directly between your project and its history. Đúng hơn là Git đầu tiên ghi
dữ liệu vào chỉ mục, và sau đó sao chép dữ liệu trong chỉ mục vào chỗ ghi
cuối.

Ví dụ, lệnh *commit -a* thực sự bao gồm hai quá trình. Bước thứ nhất là đặt
snapshot of the current state of every tracked file vào chỉ mục (index). Bước thứ
hai là permanently records the snapshot now in the index. Việc commit không sử dụng tùy chọn
*-a* chỉ thi hành bước thứ hai, and only makes sense after running
commands that somehow change the index, như là lệnh *git add*.

Usually we can ignore the index and pretend we are reading straight from and ghi thẳng vào trong lịch sử. On this occasion, we want finer control, so we manipulate the index. We place a snapshot of some, không phải tất cả, các thay đổi của chúng ta vào chỉ mục, and then permanently record this carefully rigged snapshot.

=== Đừng Quên HEAD của Mình ===

Thẻ HEAD giống như một con trỏ, nó trỏ đến lần commit cuối cùng, tự động di chuyển theo mỗi lần commit mới. Một số lệnh của Git giúp bạn di chuyển nó. Ví dụ như:

 $ git reset HEAD~3

sẽ chuyển HEAD lên vị trí lần commit cách đây ba lần. Thus all Git commands now act as if you hadn't made those last three commits, while your files remain in the present. See the help page for some applications.

Nhưng ta lại muốn quay trở lại phần sau này? Lần commit cũ không biết gì về phần sau này cả.

Nếu bạn có giá trị băm SHA1 của HEAD gốc thì:

 $ git reset 1b6d

Nhưng giả sử bạn không có được nó? Đừng lo: với những lệnh như thế, Git ghi lại HEAD gốc với thẻ có tên là ORIG_HEAD, và bạn có thể trở về ngon lành và an toàn với lệnh:

 $ git reset ORIG_HEAD

=== Săn tìm-HEAD ===

Có thể ORIG_HEAD là chưa đủ. Có lẽ you've just realized you made a monumental mistake and you need to go back to an ancient commit in a long-forgotten branch.

Theo mặc định, Git giữ một lần commit ít nhất là hai tuần lễ, even if you ordered
Git to destroy the branch containing it. Sự trục trặc là việc tìm giá trị băm
thích hợp. Bạn có thể tìm kiếm tất cả các giá trị băm trong `.git/objects` and use trial
and error để tìm thứ mình muốn. But there's a much easier way.

Git ghi lại mọi giá trị băm của mọi lần commit trong máy tính tại thư mục `.git/logs`. Thư mục con `refs` chứa lịch sử của tất cả các hoạt động trên tất cả cách nhánh, trong khi tệp tin `HEAD` giữ tất cả các giá trị băm mà nó từng có được. The latter can be used to find hashes of commits on branches that have been accidentally lopped off.

Lệnh reflog cung cấp cho chúng ta một giao diện thân thiện dành cho các tệp tin log. Bạn có thể thử bằng lệnh:

  $ git reflog

Thay vì phải cắt và dán giá trị băm từ reflog, hãy thử:

 $ git checkout "@{10 minutes ago}"

Hay checkout lần thứ 5th-last visited commit via:

 $ git checkout "@{5}"

Xem chương ``Specifying Revisions'' từ lệnh *git help rev-parse* để biết thêm chi tiết.

You may wish to configure a longer grace period for doomed commits. Ví
dụ:

  $ git config gc.pruneexpire "30 days"

có nghĩa là việc xóa một lần commit sẽ thực sự xảy ra khi 30 ngày đã qua và
lệnh *git gc* được gọi.

Bạn cũng có thể không cho phép chạy lệnh *git gc* một cách tự động:

  $ git config gc.auto 0

trong trường hợp này những lần commit sẽ chỉ bị xóa bỏ khi bạn chạy lệnh *git gc*.

=== Building On Git ===

In true UNIX fashion, Git được thiết kế cho phép nó dễ dàng được sử dụng như là một thành phần bên dưới của các chương trình khác, như là cho giao diện đồ họa GUI và giao diện Web, thay thế cho giao diện dòng lệnh, công cụ quản lý các miếng vá, các công cụ nhập và chuyển đổi, và những thứ tương tự như thế. Trên thực tế, một số lệnh Git bản chất nó cũng là các kịch bản (scripts) đứng trên vai của những người khổng lồ, chính là hệ điều hành. Chỉ cần sửa đổi một chút, bạn có thể bắt Git làm việc phù hợp với sở thích của mình.

Một mẹo nhỏ là sử dụng một built-in của Git là gán bí danh cho các lệnh để nó trở nên ngắn gọn hơn
sử dụng lệnh:

  $ git config --global alias.co checkout  #gán bí danh cho lệnh checkout là co
  $ git config --global --get-regexp alias  # hiển thị bí danh hiện hành
  alias.co checkout
  $ git co foo                              # có kết quả giống như chạy lệnh 'git checkout foo'

Một thứ khác là hiển thị nhánh hiện hành lên màn hình hay thanh tiêu đề của cửa sổ.
Gọi lệnh

  $ git symbolic-ref HEAD

sẽ hiển thị tên của nhánh hiện hành. Trong thực tiễn, you most likely want to remove
the "refs/heads/" and ignore errors:

  $ git symbolic-ref HEAD 2> /dev/null | cut -b 12-

The +contrib+ subdirectory is a treasure trove of tools built on Git.
In time, some of them may be promoted to official commands. On Debian and
Ubuntu, this directory lives at +/usr/share/doc/git-core/contrib+.

One popular resident is +workdir/git-new-workdir+. Via clever symlinking, this script creates a new working directory whose history is shared with the original repository:

  $ git-new-workdir an/existing/repo new/directory

Thư mục mới và các tệp tin trong nó có thể can be thought of as a clone, except since the history is shared, the two trees automatically stay in sync. Ở đây không cần có sự trộn, push, hay pull.

=== Daring Stunts ===

These days, Git makes it difficult for the user to accidentally destroy data.
But if you know what you are doing, you can override safeguards for common
commands.

*Checkout*: Uncommitted changes cause checkout to fail. To destroy your changes, and checkout a given commit anyway, use the force flag:

  $ git checkout -f HEAD^

On the other hand, if you specify particular paths for checkout, then there are no safety checks. The supplied paths are quietly overwritten. Take care if you use checkout in this manner.

*Reset*: Reset also fails in the presence of uncommitted changes. To force it through, run:

  $ git reset --hard 1b6d

*Branch*: Deleting branches fails if this causes changes to be lost. Để ép buộc việc xóa, hãy gõ:

  $ git branch -D dead_branch  #thay vì sử dụng tùy chọn -d

Cũng tương tự như thế, attempting to overwrite a branch via a move fails if data loss would ensue. To force a branch move, type:

  $ git branch -M source target  # thay vì sử dụng tùy chọn -m

Không giống như checkout và reset, hai lệnh trên trì hoãn việc phá hủy dữ liệu. The
changes are still stored trong thư mục con .git, và có thể lấy lại được bằng cách
lấy giá trị băm `.git/logs` thích hợp (xem "Săn tìm - HEAD" ở phía trên).
Theo mặc định, chúng sẽ giữ ít nhất là hai tuần lễ.

*Clean*: Một số lệnh Git từ chối commands refuse to proceed because they're worried about
clobbering untracked files. Nếu bạn chắc chắn về tất cả các tệp tin và thư mục không cần Git
theo dõi nữa và muốn phá hủy chúng đi, thế thì xóa chúng triệt để với lệnh:

  $ git clean -f -d

Next time, that pesky command will work!

=== Preventing Bad Commits ===

Stupid mistakes pollute my repositories. Điều tồi tệ nhất là để sót các tệp tin bởi vì
quên lệnh *git add*. Ít tệ hại hơn là các ký tự khoảng trắng đã gây nên xung đột khi trộnLesser transgressions are trailing whitespace and
unresolved merge conflicts: mặc dù cũng chẳng tệ hại lắm, Tôi mong rằng những điều này sẽ không xảy ra
với mọi người.

If only I had bought idiot insurance by using a _hook_ to alert me about these problems:

 $ cd .git/hooks
 $ cp pre-commit.sample pre-commit  # Older Git versions: chmod +x pre-commit

Now Git aborts a commit if useless whitespace or unresolved merge conflicts are
detected.

Với bản hướng dẫn này, I eventually added the following to the beginning of the
*pre-commit* hook to guard against absent-mindedness:

 if git ls-files -o | grep '\.txt$'; then
   echo FAIL! Untracked .txt files.
   exit 1
 fi

Nhiều hoạt động của Git hỗ trợ hooks; hãy xem *git help hooks*. Chúng tôi đã kích hoạt
một hook mẫu là *post-update* trước earlier when discussing Git thông qua HTTP. This runs
whenever the head moves. Đoạn script ví dụ post-update cập nhật các tệp tin Git cần
for communication over Git-agnostic transports giống như là HTTP.
