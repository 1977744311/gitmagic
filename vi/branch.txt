== Branch Wizardry ==

Tạo nhánh và trộn là các đặc tính sát thủ của Git.

*Problem*: External factors inevitably necessitate context switching. A severe
bug manifests in the released version without warning. The deadline for a
certain feature is moved closer. A developer whose help you need for a key section of the project is about to leave. In all cases, you must abruptly drop what you are doing and focus on a completely different task.

Interrupting your train of thought can be detrimental to your productivity, and the more cumbersome it is to switch contexts, the greater the loss. With centralized version control we must download a fresh working copy from the central server. Distributed systems fare better, as we can clone the desired version locally.

But cloning still entails copying the whole working directory as well as the entire history up to the given point. Dù là Git reduces the cost of this with file sharing and hard links, the project files themselves must be recreated in their entirety in the new working directory.

*Solution*: Git có một công cụ tốt hơn để sử lý tình huống này, nó nhanh và tiết kiệm không gian lưu trữ hơn lệnh cloning: *git branch*.

With this magic word, the files in your directory suddenly shapeshift from one version to another. This transformation can do more than merely go back or forward in history. Your files can morph from the last release to the experimental version to the current development version to your friend's version and so on.

=== The Boss Key ===

Ever played one of those games where at the push of a button (``the boss key''), màn hình có lẽ hiển thị ngay một cái bảng hay một thứ gì đó? Thế thì nhỡ ông chủ của bạn đang đi lại trong văn phòng nơi bạn đang chơi trò chơi thì làm cách nào để nhanh chóng giấu chúng đi?

Ở thư mục nào đó:

 $ echo "I'm smarter than my boss" > myfile.txt
 $ git init
 $ git add .
 $ git commit -m "Lần commit bắt đầu"

Chúng ta đã tạo ra kho chứa Git mà nó theo dõi một tệp tin văn bản có chứa một thông điệp đã biết trước. Giờ hãy gõ:

 $ git checkout -b boss  # nothing seems to change after this
 $ echo "My boss is smarter than me" > myfile.txt
 $ git commit -a -m "Another commit"

Điều này cũng giống như việc chúng ta ghi đè lên tệp tin của mình sau đó commit nó. Nhưng đó chỉ là ảo tưởng. Gõ:

 $ git checkout master  # quay trở lại phiên bản nguyên gốc của tệp tin

Ối trời ơi! Tệp tin văn bản lại trở về như cũ mất rồi. Và nếu ông chủ có ý định ngó qua thư mục của bạn thì hãy gõ:

 $ git checkout boss  # chuyển trở lại phiên bạn vừa mắt ông chủ

Bạn có thể hoán chuyển giữa hai phiên bản của tệp tin tùy thích, và commit từng cái trong số chúng một cách độc lập.

=== Dirty Work ===

[[branch]]
Bạn nói mình đang làm việc với một số đặc tính kỹ thuật, và vì lý do nào đó, bạn muốn quay trở lại bản cách đây ba bản và tạm thời đặt vài dòng lệnh
in ra màn hình để có thể thấy được một số chức năng hoạt động như thế nào. Thế thì:

 $ git commit -a
 $ git checkout HEAD~3

Giờ thì bạn có thể thêm những dòng code tạm thời ở đâu mình muốn. Bạn còn có thể commit những thay đổi đó. Khi bạn đã làm xong,

 $ git checkout master

để quay lại công việc chính. Observe that any uncommitted changes are carried over.

Nhưng bạn lại muốn ghi lại các thay đổi tạm thời đó sau khi làm xong? Rất dễ:

 $ git checkout -b dirty

và commit trước khi quay trở lại nhánh master. Khi nào đó bạn muốn quay trở lại các thay đổi ở trên, đơn giản, chỉ cần gõ:

 $ git checkout dirty

We touched upon this command in an earlier chapter, when discussing loading old states. At last we can tell the whole story: the files change to the requested state, but we must leave the master branch. Any commits made from now on take your files down a different road, which can be named later.

In other words, after checking out an old state, Git automatically puts you in a new, unnamed branch, which can be named and saved with *git checkout -b*.

=== Quick Fixes ===

Bạn đang phân vân giữa ngã ba đường khi bạn are told to drop everything and fix a newly discovered lỗi trong lần commit `1b6d...`:

 $ git commit -a
 $ git checkout -b fixes 1b6d

Then once you've fixed the bug:

 $ git commit -a -m "Bug fixed"
 $ git push  # tới kho chứa trung tâm
 $ git checkout master

và phục hồi lại cong việc trên and resume work on your original task.

Bạn thậm chí có thể 'merge' in the bugfix you just made, dùng một trong hai lệnh sau:

 $ git merge fixes

hay là:

 $ git pull

since you have already pushed the bugfix tới kho chứa chính.

=== Merging ===

Với một số hệ thống quản lý mã nguồn, việc tạo các nhánh rất dễ dàng nhưng trộn chúng
trở lại là một bài toán hóc búa. Với Git, việc trộn là dễ dàng that you might be
unaware of it happening.

Chúng ta đã sử dụng việc trộn từ lâu rồi. Lệnh *pull* trên thực tế đã 'fetches'
các lần commit và sau đó trộng chúng vào trong nhánh hiện hành của bạn. If you have no local
changes, then the merge is a 'fast forward', a degenerate case akin to fetching
the latest version in a centralized version control system. But if you do have
local changes, Git sẽ tự động merge, và báo cáo cho bạn nếu có lỗi xảy ra.

Ordinarily, a commit has exactly one 'parent commit', namely, the previous
commit. Merging branches together produces a commit with at least two parents.
This begs the question: what commit does `HEAD~10` really refer to? A commit
could have multiple parents, so which one do we follow?

It turns out this notation chooses the first parent every time. This is
desirable because the current branch becomes the first parent during a merge;
frequently you're only concerned with the changes you made in the current
branch, as opposed to changes merged in from other branches.

You can refer to a specific parent with a caret. Ví dụ, để hiển thị
the logs from the second parent:

 $ git log HEAD^2

You may omit the number for the first parent. Ví dụ, để hiển thị
sự khác nhau với differences with the first parent:

 $ git diff HEAD^

Bạn có thể tổ hợp các dấu mũ này với các kiểu khác. Ví dụ:

 $ git checkout 1b6d^^2~10 -b ancient

bắt đầu một nhánh mới ``ancient'' tương ứng với trạng thái (state) lần commit thứ 10 back from the
second parent of the first parent of the của lần commit bắt đầu với 1b6d.

=== Uninterrupted Workflow ===

Thường trong các dự án phần cứng, bước thứ hai của kế hoạch phải chờ bước thứ nhất hoàn thành. A car undergoing repairs might sit idly in a garage cho đến khi các chi tiết phụ tùng đặc biệt được chuyển đến từ nhà máy. Một mẫu có thể phải chờ một con chip được làm ra trước khi quá trình chế tác có thể tiếp tục.

Dự án phần mềm cũng có thể tương tự như thế. Bộ phận thứ hai có một số tính năng có thể phải
chờ cho đến khi phần thứ nhất đã được phát hành và kiểm tra. Một số dự án yêu cầu
mã nguồn của bạn phải được xem xét lại trước khi chấp nhận nó, vì vậy bạn có thể phải chờ cho đến khi bộ phận
thứ nhất đã được chấp thuận trước khi bắt đầu phần thứ hai.

Thanks to painless branching and merging, we can bend the rules and work on
Part II before Part I is officially ready. Suppose you have committed Part I
and sent it for review. Let's say you're in the `master` branch. Then branch
off:

 $ git checkout -b part2

Next, work on Part II, committing your changes along the way. To err is human,
and often you'll want to go back and fix something in Part I.
Nếu may mắn,If you're lucky, or very good, you can skip these lines.

 $ git checkout master  # Go back to Part I.
 $ fix_problem
 $ git commit -a        # Commit the fixes.
 $ git checkout part2   # Go back to Part II.
 $ git merge master     # Merge in those fixes.

Cuối cùng, Part I được chấp thuận:

 $ git checkout master  # Go back to Part I.
 $ submit files         # Release to the world!
 $ git merge part2      # Merge in Part II.
 $ git branch -d part2

Now you're in the `master` branch again, with Part II in the working directory.

It's easy to extend this trick for any number of parts. It's also easy to
branch off retroactively: suppose you belatedly realize you should have created
a branch 7 commits ago. Thế thì gõ:

 $ git branch -m master part2
 $  # Rename "master" branch to "part2".
 $ git checkout HEAD~7 -b master

The `master` branch now contains just Part I, and the `part2` branch contains
the rest.

=== Reorganizing a Medley ===

Perhaps you like to work on all aspects of a project in the same branch. You want to keep works-in-progress to yourself and want others to see your commits only when they have been neatly organized. Start a couple of branches:

  $ git checkout -b sanitized
  $ git checkout -b medley

Next, work on anything: sửa lỗi, thêm các đặc tính kỹ thuật, thêm mã lệnh tạm thời, vân vân, committing often along the way. Then:

  $ git checkout sanitized
  $ git cherry-pick medley^^

applies the grandparent of the head commit of the ``medley'' branch to the ``sanitized'' branch. With appropriate cherry-picks you can construct a branch that contains only permanent code, and has related commits grouped together.

=== Quản Lý Các Nhánh ===

Liệt kê tất cả các nhánh bằng cách gõ:

 $ git branch

Theo mặc định, bạn bắt đầu tại nhánh có tên ``master''. Một số người chủ trương rời bỏ
nhánh ``master'' mà không động chạm gì đến nó và tạo các nhánh mới cho các chỉnh sửa của riêng mình.

Các tùy chọn *-d* and *-m* cho phép bạn xóa hay di chuyển (đổi tên) các nhánh.
Xem thêm *git help branch*.

Nhánh ``master'' thông thường rất hữu dụng. Others may assume that your
repository has a branch with this name, and that it contains the official
version of your project. Mặc dù bạn có thể đổi tên hay xóa bỏ nhánh ``master'',
Bạn nên lưu tâm đến you might as well respect this convention.

=== Nhánh Tạm ===

After a while you may realize you are creating short-lived branches
frequently for similar reasons: every other branch merely serves to
save the current state so you can briefly hop back to an older state to
fix a high-priority bug or something.

Điều này cũng tương tự như việc chuyển kênh trên TV một cách tạm thời để thấy chương trình khác đang chiếu.
Nhưng thay vì chỉ cần nhấn vài cái nút, bạn phải tạo, check out,
trộn và xóa nhánh tạm đó. May mắn thay, Git có cách ngắn gọn tiện lợi
chẳng thua kém gì chiếc điều khiển từ xa của một chiếc TV:

 $ git stash

Lệnh này ghi lại trạng thái hiện hành vào một vị trí tạm thời (một 'stash') và
phục hồi lại trạng thái trước đó. Thư mục bạn đang làm việc xuất hiện chính xác
như trước khi bạn chỉnh sửa, và bạn có thể sửa lỗi, pull in upstream changes, và
cứ như thế. When you want to go back to the stashed state, gõ:

 $ git stash apply  # Bạn có thể phải giải quyết các xung đột.

You can have multiple stashes, and manipulate them in various ways. See
*git help stash*. As you may have guessed, Git maintains branches behind the scenes to perform this magic trick.

=== Làm Theo Cách Của Mình ===

You might wonder if branches are worth the bother. Cuối cùng, clones are almost
as fast, và bạn có thể hoán chuyển giữa chúng với lệnh *cd* thay vì sử dụng
lệnh riêng của Git.

Ta thử xét đến các trình duyệt web. Tại sao việc hỗ trợ mở nhiều tab thì cũng tốt như mở trên nhiều cửa sổ khác nhau?
Bởi vì cả hai điều này thể hiện tính đa dạng của quan điểm, phong cách sống. Một số người sử dụng lại thích
chỉ giữ một cửa sổ trình duyệt được mở, và sử dụng các tab để hiển thị nhiều trang web một lúc. Những người khác
có lẽ lại khăng khăng cực đoan cho rằng: mở trên nhiều cửa sổ khác nhau và chẳng cần tab nữa.
Một nhóm khác lại thích cả hai một lúc.

Việc tạo nhánh thì cũng giống như các tab cho thư mục làm việc của bạn, việc nhân bản thì giống như việc mở một cửa sổ duyệt mới. Những việc này nhanh chóng và nội bộ, thế thì sao lại không
thử nghiệm để tìm thấy cách thực hiện thích hợp nhất cho mình? Git giúp bạn làm việc chính xác
như bạn muốn.
