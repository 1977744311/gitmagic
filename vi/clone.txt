== Lệnh Clone ==

Trong các hệ thống quản lý mã nguồn trước đây, checkout là tác vụ cơ bản để lấy các tệp tin về. Bạn lấy về toàn bộ các tập tin được lưu giữ trong từng phiên bản riêng biệt.

Với Git và các hệ thống quản lý mã nguồn phân tán, clone là tác vụ cơ bản. Để lấy các tệp tin, bạn tạo một 'clone' (bản sao) của toàn bộ kho chứa. Nói cách khác, bạn thực tế là một bản sao của máy chủ trung tâm. Bất kỳ cái gì bạn thể làm được với kho chứa chính thì cũng làm được ở đây.

=== Đồng bộ hóa Các Máy tính ===

Tôi có thể tạo gói tarball hay sử dụng lệnh *rsync* để sao lưu (backup) và đồng bộ hóa dữ liệu. Nhưng thỉnh thoảng, tôi biên tập trên laptop của mình, nhưng lúc khác lại trên máy tính để bàn, và chúng có thể không có sự trao đổi với nhau.

Khởi tạo kho chứa Git và commit các tệp tin trên một máy tính. Sau đó trên máy tính kia chạy lệnh:

 $ git clone other.computer:/path/to/files

để tạo một bản sao thứ hai cho các tệp tin và kho chứa. Từ giờ trở đi,

 $ git commit -a
 $ git pull other.computer:/path/to/files HEAD

sẽ 'pull' in the state of the files on the other computer into the one you're working on. Nếu bạn vừa tạo ra một sự chỉnh sửa
xung đột trong cùng một tệp tin , Git sẽ cho bạn biết và bạn có thể commit lại sau khi sửa chữa chúng.

=== Classic Source Control ===

Khởi tạo kho Git cho các tệp tin của bạn:

 $ git init
 $ git add .
 $ git commit -m "Initial commit"

Trên máy chủ trung tâm, khởi tạo 'bare repository' ở một thư mục nào đó:

 $ mkdir proj.git
 $ cd proj.git
 $ git init --bare
 $  # one-line variant: GIT_DIR=proj.git git init

Khởi động dịch vụ Git daemon nếu cần:

 $ git daemon --detach  # nó có thể đã hoạt động rồi

Để làm một máy chủ chạy dịch vụ Git, làm theo các chỉ dẫn sau để cài đặt
và khởi tạo kho Git. Cách thường thấy là điền vào form trên trang web.

'Push' dự án của bạn lên máy chủ trung tâm bằng lệnh:

 $ git push git://central.server/path/to/proj.git HEAD

Để check out mã nguồn, các nhà phát triển phần mềm chỉ cần gõ:

 $ git clone git://central.server/path/to/proj.git

Sau khi thay đổi, các nhà phát triển phần mềm sẽ lưu lại các thay đổi trên máy tính của mình:

 $ git commit -a

Để cập nhật lên bản mới nhất:

 $ git pull

Mọi xung đột phải được xử lý trước, sau đó mới commit:

 $ git commit -a

Gửi thay đổi của mình lên máy chủ trung tâm:

 $ git push

Nếu máy chủ trung tâm có thay đổi bởi hành động của một người phát triển phần mềm khác, quá trình
push sẽ bị lỗi, và anh ta phải pull về bản mới nhất, xử lý các xung đột
khi trộn, sau đó thử lại.

=== Kho Bare ===

Kho bare (kho trần) được đặt tên như vậy vì nó không chứa thư mục làm việc; nó chỉ chứa các tệp tin thường là ẩn trong thư mục phụ `.git`. Hay nói cách khác, nó chứa lịch sử mã nguồn của một dự án, và không bao giờ giữ snapshot của bất kỳ phiên bản nào.

Kho bare có vai trò hoạt động giống như máy chủ trung tâm trong các hệ thống
quản lý mã nguồn tập trung: the home of your project. Các nhà phát triển phần mềm clone
dữ liệu dự án của bạn ở đây, và push các thay đổi chính thức lên đó. Typically it
resides on a server that does little else but disseminate data. Development
occurs in the clones, so the home repository can do without a working
directory.

Nhiều lệnh Git commands gặp lỗi fail on bare repositories trừ phi biến môi trường `GIT_DIR` được đặt với giá trị là đường dẫn đến kho chứa, hay tùy chọn `--bare` được áp dụng.

=== Push versus pull ===

Why did we introduce the push command, rather than rely on the familiar pull
command? Trước hết, pulling fails on bare repositories: instead you must 'fetch',
a command we later discuss. But even if we kept a normal repository on the
central server, pulling into it would still be cumbersome. We would have to
login to the server first, and give the pull command the network address of the
machine we're pulling from. Firewalls may interfere, and what if we have no
shell access to the server in the first place?

Tuy nhiên, ngoài trường hợp này ra, we discourage pushing into a repository, bởi vì tình trạng hỗn loạn có thể xảy khi thư mục đích có chứa thư mục làm việc.

Tóm lại, khi học Git, chỉ push khi đích là kho bare; nếu không thì dùng pull.

=== Rẽ nhánh Dự án ===

Bạn chán ngấy cách mà dự án mà bạn đang làm việc chạy? Bạn nghĩ mình có thể làm tốt hơn thế? Thế thì trên máy chủ của mình:

 $ git clone git://main.server/path/to/files

Tiếp theo, nói với mọi người về nhánh rẽ từ dự án của bạn tại máy chủ của bạn.

Từ giờ trở đi, bạn có thể trộn các sự thay đổi từ dự án gốc với you can merge in the changes from the original project with:

 $ git pull

=== Ultimate Backups ===

Want numerous tamper-proof geographically diverse redundant archives? Nếu dự án của bạn có nhiều người cùng phát triển, bạn không cần phải làm gì cả! Mỗi một bản clone đều đồng thời có tác dụng như một bản sao lưu dự phòng. Not just of the current state, but of your project's entire history. Thanks to cryptographic hashing, if anyone's clone becomes corrupted, it will be spotted as soon as they try to communicate with others.

Nếu dự án của bạn không phổ biến, hãy tìm càng nhiều máy chủ lưu giữ bản clone của bạn càng nhiều càng tốt.

The truly paranoid should always write down the latest 20-byte giá trị băm SHA1 của HEAD ở đâu đó an toàn. Nó phải an toàn, không riêng tư. Ví dụ, xuất bản nó lên báo giấy cũng tốt, bởi vì rất khó để thay đổi tất cả các bản sao của nó.

=== Light-Speed Multitask ===

Say you want to work on several features in parallel. Sau đó commit dự án của bạn và chạy:

 $ git clone . /some/new/directory

Git exploits hard links and file sharing as much as safely possible to create this clone, so it will be ready in a flash, and you can now work on two independent features simultaneously. Ví dụ như, you can edit one clone while the other is compiling.

Bất kỳ lúc nào, bạn cũng có thể commit và pull các thay đổi từ một bản sao (clone) khác.

 $ git pull /the/other/clone HEAD

=== Guerilla Version Control ===

Bạn đang làm việc cho một dự án có sử dụng hệ thống quản lý mã nguồn cũ, và bạn lại muốn sử dụng Git? Thế thì hãy khởi tạo kho chứa Git trong thư mục bạn đang làm việc:

 $ git init
 $ git add .
 $ git commit -m "Initial commit"

sau đó clone nó:

 $ git clone . /some/new/directory

Bây giờ hãy chuyển đến thư mục mới đó và làm việc ở đây thay vì chỗ cũ, sử dụng Git to your heart's content. Đôi khi, bạn sẽ muốn đồng bộ hóa với những người khác nữa, trong trường hợp đó hãy chuyển tới thư mục nguyên bản (original), đồng bộ hóa bằng cách sử dụng một hệ thống quản lý mã nguồn khác, và gõ:

 $ git add .
 $ git commit -m "Sync with everyone else"

Sau đó chuyển tới thư mục mới và chạy:

 $ git commit -a -m "Description of my changes"
 $ git pull

The procedure for giving your changes to everyone else depends on the other version control system. The new directory contains the files with your changes. Run whatever commands of the other version control system are needed to upload them to the central repository.

Subversion, có lẽ là hệ thống quản lý mã nguồn tập trung tốt nhất, được sử dụng bởi vô số các dự án. Lệnh *git svn* sẽ tự động hóa những việc đã nói ở trên dành cho Subversion, bạn cũng có thể làm như thế để http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html[xuất dự án Git thành Subversion].

=== Mercurial ===

Mercurial là hệ thống quản lý mã nguồn is a similar version control system that can almost seamlessly work in tandem with Git. Với  plugin `hg-git`, người sử dụng Mercurial có thể push và pull từ kho Git mà không mất mát gì.

Lấy plugin `hg-git` dành cho Git bằng cách:

 $ git clone git://github.com/schacon/hg-git.git

hay là sử dụng Mercurial:

 $ hg clone http://bitbucket.org/durin42/hg-git/

Thật buồn là tôi hay rằng có am unaware of an analogous plugin dành cho Git. Vì vậy, tôi ủng hộ Git hơn Mercurial để for the main repository, dù là bạn thích Mercurial. Với một dự án Mercurial, usually a volunteer maintains a parallel Git repository to accommodate Git users, whereas thanks to the `hg-git` plugin, a Git project automatically accommodates Mercurial users.

Mặc dù plugin có thể chuyển đổi Mercurial sang Git bằng cách push tới một kho rỗng, công việc này là dễ dàng với script `hg-fast-export.sh`, đã sẵn dùng từ:

 $ git clone git://repo.or.cz/fast-export.git

Để chuyển đổi, trong một thư mục rỗng hãy chạy:

 $ git init
 $ hg-fast-export.sh -r /hg/repo

sau khi đặt script vào trong biến môi trường `$PATH`.

=== Bazaar ===

Chúng tôi đề cập vắn tắt về Bazaar bởi vì nó là hệ thống quản lý mã nguồn phân tán
miễn phí và phổ biến nhất chỉ sau Git và Mercurial.

Bazaar has the advantage of hindsight, as it is relatively young; its designers could learn from mistakes of the past, and sidestep minor historical warts. Ngoài ra, its developers are mindful of portability and interoperation with other version control systems.

Plugin `bzr-git` giúp người dùng Bazaar làm việc với kho Git to some extent. The `tailor` program chuyển đổi Bazaar thành Git, and can do so incrementally, trong khi `bzr-fast-export` thích hợp nhất cho one-shot conversions.

=== Tại sao Tôi sử dụng Git ===

Trước tiên, tôi chọn Git bởi tôi nghe nói nó làm được việc phi thường là có thể quản lý mã nguồn cho một thứ khó quản lý như nhân (kernel) của hệ điều hành Linux. Tôi chưa bao giờ nghĩ đến việc chuyển sang cái khác. Git làm được những việc thật đáng ngưỡng mộ, and I've yet to be bitten by its flaws. Do tôi hoạt động chủ yếu trên Linux, issues on other platforms are of no concern.

Ngoài ra, Thôi thích lập trình bằng ngôn ngữ C và bash scripts to executables such as Python scripts: there are fewer dependencies, and I'm addicted to fast running times.

Tôi đã nghĩ về việc làm thế nào để Git có thể phát triển, xa hơn nữa là tự mình viết một công cụ tương tự như Git, but only as an academic exercise. Had I completed my project, I would have stayed with Git anyway, as the gains are too slight to justify using an oddball system.

Rất tự nhiên, những thứ cần thiết và mong muốn của bạn có lẽ khác nhau, và bạn có thể tốt hơn nếu ở một hệ thống khác. Dù sao đi nữa, bạn sẽ không bao giờ phải hối tiếc vì đã chọn Git.
