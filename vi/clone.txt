== Cloning Around ==

Trong các hệ thống quản lý mã nguồn trước đây, checkout là tác vụ cơ bản để lấy các tệp tin về. Bạn lấy về toàn bộ các tập tin được lưu giữ trong từng phiên bản riêng biệt.

Với Git và các hệ thống quản lý mã nguồn phân tán, cloning là tác vụ cơ bản. Để lấy các tệp tin, bạn tạo một 'clone' (bản sao) của toàn bộ kho chứa. Nói cách khác, bạn thực tế là một bản sao của máy chủ trung tâm. Bất kỳ cái gì bạn làm với kho chứa chính thì cũng làm được ở đây.

=== Đồng bộ hóa Các Máy tính ===

I can tolerate making tarballs or using *rsync* for backups and basic syncing. But sometimes I edit on my laptop, other times on my desktop, and the two may not have talked to each other in between.

Khởi tạo kho chứa Git và commit các tệp tin trên một máy tính. Sau đó trên máy tính kia chạy lệnh:

 $ git clone other.computer:/path/to/files

để tạo một bản sao thứ hai cho các tệp tin và kho chứa. Từ giờ trở đi,

 $ git commit -a
 $ git pull other.computer:/path/to/files HEAD

sẽ 'pull' in the state of the files on the other computer into the one you're working on. If you've recently made conflicting edits in the same file, Git sẽ cho bạn biết và bạn có thể commit lại sau khi sửa chữa chúng.

=== Classic Source Control ===

Khởi tạo kho Git cho các tệp tin của bạn:

 $ git init
 $ git add .
 $ git commit -m "Initial commit"

Trên máy chủ trung tâm, khởi tạo 'bare repository' ở một thư mục nào đó:

 $ mkdir proj.git
 $ cd proj.git
 $ git init --bare
 $  # one-line variant: GIT_DIR=proj.git git init

Khởi động Git daemon nếu cần:

 $ git daemon --detach  # it may already be running

For Git hosting services, follow the instructions to setup the initially
empty Git repository. Typically one fills in a form on a webpage.

'Push' dự án của bạn lên máy chủ trung tâm bằng lệnh:

 $ git push git://central.server/path/to/proj.git HEAD

Để check out mã nguồn, các nhà phát triển chỉ cần gõ:

 $ git clone git://central.server/path/to/proj.git

Sau khi thay đổi, các nhà phát triển phần mềm sẽ lưu lại các thay đổi trên máy tính của mình:

 $ git commit -a

Để cập nhật lên bản mới nhất:

 $ git pull

Any merge conflicts should be resolved then committed:

 $ git commit -a

Gửi thay đổi của mình lên máy chủ trung tâm:

 $ git push

If the main server has new changes due to activity by other developers, the
push fails, and the developer should pull the latest version, resolve any merge
conflicts, sau đó thử lại.

=== Bare repositories ===

A bare repository is so named because it has no working directory; it only contains files that are normally hidden away in the `.git` subdirectory. In other words, it maintains the history of a project, and never holds a snapshot of any given version.

A bare repository plays a role similar to that of the main server in a
centralized version control system: the home of your project. Developers clone
your project from it, and push the latest official changes to it. Typically it
resides on a server that does little else but disseminate data. Development
occurs in the clones, so the home repository can do without a working
directory.

Many Git commands fail on bare repositories unless the `GIT_DIR` environment variable is set to the repository path, or the `--bare` option is supplied.

=== Push versus pull ===

Why did we introduce the push command, rather than rely on the familiar pull
command? Firstly, pulling fails on bare repositories: instead you must 'fetch',
a command we later discuss. But even if we kept a normal repository on the
central server, pulling into it would still be cumbersome. We would have to
login to the server first, and give the pull command the network address of the
machine we're pulling from. Firewalls may interfere, and what if we have no
shell access to the server in the first place?

However, apart from this case, we discourage pushing into a repository, because confusion can ensue when the destination has a working directory.

In short, while learning Git, only push when the target is a bare repository; otherwise pull.

=== Forking a Project ===

Sick of the way a project is being run? Think you could do a better job? Then on your server:

 $ git clone git://main.server/path/to/files

Next, tell everyone about your fork of the project at your server.

At any later time, you can merge in the changes from the original project with:

 $ git pull

=== Ultimate Backups ===

Want numerous tamper-proof geographically diverse redundant archives? If your project has many developers, don't do anything! Every clone of your code is effectively a backup. Not just of the current state, but of your project's entire history. Thanks to cryptographic hashing, if anyone's clone becomes corrupted, it will be spotted as soon as they try to communicate with others.

If your project is not so popular, find as many servers as you can to host clones.

The truly paranoid should always write down the latest 20-byte SHA1 hash of the HEAD somewhere safe. It has to be safe, not private. For example, publishing it in a newspaper would work well, because it's hard for an attacker to alter every copy of a newspaper.

=== Light-Speed Multitask ===

Say you want to work on several features in parallel. Then commit your project and run:

 $ git clone . /some/new/directory

Git exploits hard links and file sharing as much as safely possible to create this clone, so it will be ready in a flash, and you can now work on two independent features simultaneously. For example, you can edit one clone while the other is compiling.

At any time, you can commit and pull changes from the other clone.

 $ git pull /the/other/clone HEAD

=== Guerilla Version Control ===

Bạn đang làm việc cho một dự án có sử dụng hệ thống quản lý mã nguồn cũ, và bạn lại muốn sử dụng Git? Thế thì khởi tạo kho chứa Git trong thư mục bạn đang làm việc:

 $ git init
 $ git add .
 $ git commit -m "Initial commit"

sau đó clone nó:

 $ git clone . /some/new/directory

Bây giờ hãy chuyển đến thư mục mới đó và làm việc ở đây thay vì chỗ cũ, using Git to your heart's content. Once in a while, you'll want to sync with everyone else, in which case go to the original directory, sync using the other version control system, and type:

 $ git add .
 $ git commit -m "Sync with everyone else"

Sau đó chuyển tới thư mục mới và chạy:

 $ git commit -a -m "Description of my changes"
 $ git pull

The procedure for giving your changes to everyone else depends on the other version control system. The new directory contains the files with your changes. Run whatever commands of the other version control system are needed to upload them to the central repository.

Subversion, perhaps the best centralized version control system, is used by countless projects. The *git svn* command automates the above for Subversion repositories, and can also be used to http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html[export a Git project to a Subversion repository].

=== Mercurial ===

Mercurial là hệ thống quản lý mã nguồn is a similar version control system that can almost seamlessly work in tandem with Git. Với  plugin `hg-git`, người sử dụng Mercurial có thể push và pull từ kho Git mà không tổn thất gì.

Lấy plugin `hg-git` dành cho Git bằng cách:

 $ git clone git://github.com/schacon/hg-git.git

hay sử dụng Mercurial:

 $ hg clone http://bitbucket.org/durin42/hg-git/

Thật buồn là tôi hay rằng có am unaware of an analogous plugin dành cho Git. Vì vậy, I advocate Git over Mercurial for the main repository, dù là bạn thích Mercurial. Với một dự án Mercurial, usually a volunteer maintains a parallel Git repository to accommodate Git users, whereas thanks to the `hg-git` plugin, a Git project automatically accommodates Mercurial users.

Although the plugin can convert a Mercurial repository to a Git repository by pushing to an empty repository, this job is easier with the `hg-fast-export.sh` script, available from:

 $ git clone git://repo.or.cz/fast-export.git

Để chuyển đổi, trong một thư mục rỗng hãy chạy:

 $ git init
 $ hg-fast-export.sh -r /hg/repo

sau khi đặt script vào trong biến môi trường `$PATH`.

=== Bazaar ===

We briefly mention Bazaar because it is the most popular free distributed
version control system after Git and Mercurial.

Bazaar has the advantage of hindsight, as it is relatively young; its designers could learn from mistakes of the past, and sidestep minor historical warts. Additionally, its developers are mindful of portability and interoperation with other version control systems.

A `bzr-git` plugin lets Bazaar users work with Git repositories to some extent. The `tailor` program converts Bazaar repositories to Git repositories, and can do so incrementally, while `bzr-fast-export` is well-suited for one-shot conversions.

=== Tại sao Tôi sử dụng Git ===

I originally chose Git because I heard it could manage the unimaginably unmanageable Linux kernel source. I've never felt a need to switch. Git has served admirably, and I've yet to be bitten by its flaws. As I primarily use Linux, issues on other platforms are of no concern.

Also, I prefer C programs and bash scripts to executables such as Python scripts: there are fewer dependencies, and I'm addicted to fast running times.

I did think about how Git could be improved, going so far as to write my own Git-like tool, but only as an academic exercise. Had I completed my project, I would have stayed with Git anyway, as the gains are too slight to justify using an oddball system.

Naturally, your needs and wants likely differ, and you may be better off with another system. Nonetheless, you can't go far wrong with Git.
