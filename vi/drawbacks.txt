== Phụ lục A: Hạn chế của Git ==

There are some Git issues I've swept under the carpet. Some can be handled easily with scripts and hooks, some require reorganizing or redefining the project, and for the few remaining annoyances, one will just have to wait. Or better yet, pitch in and help!

=== SHA1 Weaknesses ===

As time passes, cryptographers discover more and more SHA1 weaknesses. Already,
finding hash collisions is feasible for well-funded organizations. Trong khoảng
vài năm, perhaps even a typical PC will have enough computing power to silently
corrupt a Git repository.

Hopefully Git will migrate to a better hash function before further research
destroys SHA1.

=== Microsoft Windows ===

Sử dụng Git trên hệ điều hành Microsoft Windows có vẻ hơi cồng kềnh một chút:

- http://cygwin.com/[Cygwin], a Linux-like environment for Windows, có chứa  http://cygwin.com/packages/git/[Git đã chuyển đổi để chạy trên Windows].

- http://code.google.com/p/msysgit/[Git chạy trên MSys] là một thay thế với các hỗ trợ tối thiểu nhất, bởi vì chỉ cần một số lệnh để làm một số việc thôi.

=== Unrelated Files ===

Nếu dự án của bạn rất lơn và chứa rất nhiều tệp tin không có liên quan mà luôn luôn bị thay đổi, Git may be disadvantaged more than other systems because single files are not tracked. Git tracks changes to the whole project, which is usually beneficial.

Giải pháp là chia nhỏ dự án của bạn ra, mỗi một phần bao gồm các tệp tin liên quan. Hãy sử dụng *git submodule* nếu bạn vẫn muốn giữ mọi thứ trong một kho chung.

=== Who's Editing What? ===

Một số hệ thống quản lý mã nguồn bắt buộc bạn đánh dấu rõ ràng vào tệp tin theo một cách nào đó trước khi biên soạn. While this is especially annoying when this involves talking to a central server, it does have two benefits:

  1. Diffs are quick because only the marked files need be examined.

  2. One can discover who else is working on the file by asking the central server who has marked it for editing.

With appropriate scripting, you can achieve the same with Git. This requires cooperation from the programmer, who should execute particular scripts when editing a file.

=== File History ===

Since Git records project-wide changes, reconstructing the history of a single file requires more work than in version control systems that track individual files.

The penalty is typically slight, and well worth having as other operations are incredibly efficient. Ví dụ, `git checkout` nhanh hơn `cp -a`, and project-wide deltas compress better than collections of file-based deltas.

=== Khởi tạo Bản sao ===

Việc tạo một bản sao có vẻ hơi xa xỉ hơn là checking out trong các hệ thống quản lý mã nguồn khác khi nó có lịch sử phát triển lâu dài.

The initial cost is worth paying in the long run, như thế các tác vụ cần làm trong tương lai sẽ nhanh chóng và không cần mạng. Tuy nhiên, trong một số hoàn cảnh, it may be preferable to create a shallow clone with the với tùy chọn `--depth`. Điều này giúp làm nhanh hơn, but the resulting clone has reduced functionality.

=== Volatile Projects ===

Git was written to be fast with respect to the size of the changes. Humans make small edits from version to version. A one-liner bugfix here, a new feature there, emended comments, and so forth. But if your files are radically different in successive revisions, then on each commit, your history necessarily grows by the size of your whole project.

There is nothing any version control system can do about this, but standard Git users will suffer more since normally histories are cloned.

The reasons why the changes are so great should be examined. Perhaps file formats should be changed. Minor edits should only cause minor changes to at most a few files.

Or perhaps a database or backup/archival solution is what is actually being sought, not a version control system. For example, version control may be ill-suited for managing photos periodically taken from a webcam.

If the files really must be constantly morphing and they really must be versioned, a possibility is to use Git in a centralized fashion. One can create shallow clones, which checks out little or no history of the project. Of course, many Git tools will be unavailable, and fixes must be submitted as patches. This is probably fine as it's unclear why anyone would want the history of wildly unstable files.

Another example is a project depending on firmware, which takes the form of a huge binary file. The history of the firmware is uninteresting to users, and updates compress poorly, so firmware revisions would unnecessarily blow up the size of the repository.

In this case, the source code should be stored in a Git repository, and the binary file should be kept separately. To make life easier, one could distribute a script that uses Git to clone the code, and rsync or a Git shallow clone for the firmware.

=== Global Counter ===

Some centralized version control systems maintain a positive integer that increases when a new commit is accepted. Git refers to changes by their hash, which is better in many circumstances.

Nhưng một số người thích có nó ở dạng số nguyên. May mắn thay, it's easy to write scripts so that with every update, the central Git repository increments an integer, perhaps in a tag, and associates it with the hash of the latest commit.

Every clone could maintain such a counter, but this would probably be useless, since only the central repository and its counter matters to everyone.

=== Các thư mục rỗng ===

Các thư mục rỗng không được theo dõi. Create dummy files to work around this problem.

Xét về mặt thi hành của Git, thay vì sự thiết kế của nó, điều hạn chế này này là đáng trách. With luck, once Git gains more traction, more users will clamour for this feature and it will be implemented.

=== Initial Commit ===

A stereotypical computer scientist counts từ 0, thay vì 1. Thật không may, with respect to commits, git does not adhere to this convention. Many commands are unfriendly before the initial commit. Thêm nữa, some corner cases must be handled specially, such as rebasing a branch with a different initial commit.

Git would benefit from defining the zero commit: as soon as a repository is constructed, HEAD được đặt cho một chuỗi ký tự bao gồm 20 byte rỗng. This special commit tương ứng với một cây (tree) rỗng, không có gốc, at some time predating all Git repositories.

Then running git log, for example, would inform the user that no commits have been made yet, instead of exiting with a fatal error. Similarly for other tools.

Every initial commit is implicitly a descendant of this zero commit.

Tuy nhiên, ở đây có một số vấn đề there are some problem cases unfortunately. Nếu nhiều nhánh  If several branches with different initial commits are merged together, then rebasing the result requires substantial manual intervention.

=== Giao diện Lập lờ ===

Để commit A và B, nghĩa của biểu thức "A..B" và "A...B" tùy thuộc vào
việc lệnh mong đó là hai điểm mút hay một vùng. Xem *git help diff*
và *git help rev-parse*.
