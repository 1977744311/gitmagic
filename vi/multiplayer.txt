== Multiplayer Git ==

Lúc đầu tôi sử dụng Git cho dự án riêng mà tôi là người duy nhất phát triển nó.
Amongst the commands related to Git's distributed nature, Tôi chỉ cần lệnh *pull*
và *clone* so could I keep the same project in different places.

Sau đó tôi muốn mã nguồn của mình được phổ biến trên mạng bằng việc sử dụng Git, và bao gồm cả những thay đổi từ
những người đóng góp. Tôi đã phải học cách làm thế nào để quản lý các dự án có nhiều người phát triển phần mềm
ở khắp nơi trên toàn thế giới. May mắn thay, đây là sở trường của Git, và người ta có thể nói đây là
điều sống còn


=== Tôi Là Ai? ===

Mỗi lần commit sẽ có tên và địa chỉ thư điện tử, điều này có thể nhìn thấy bằng lệnh *git log*.
Theo mặc định, Git uses system settings to populate these fields.
Để chỉ định chúng một cách rõ ràng, hãy gõ:

  $ git config --global user.name "John Doe"
  $ git config --global user.email johndoe@example.com

Omit the global flag to set these options only for the current repository.

=== Git Thông Qua SSH, HTTP ===

Giả sử bạn có thể truy cập vào một máy chủ web qua SSH, nhưng Git lại chưa được cài đặt ở đây. Mặc dù
không hiệu quả như giao thức nguyên bản của nó, nhưng Git vẫn có thể truyền thông thông qua HTTP.

Download, compile and install Git in your account, and create a repository in
your web directory:

 $ GIT_DIR=proj.git git init
 $ cd proj.git
 $ git --bare update-server-info
 $ cp hooks/post-update.sample hooks/post-update

Với các phiên bản Git cũ, lệnh copy không thực hiện được và bạn phải chạy:

 $ chmod a+x hooks/post-update

Now you can publish your latest edits thông qua SSH từ một bản sao bất kỳ:

 $ git push web.server:/path/to/proj.git master

và mọi người có thể lấy dự án của bạn với lệnh:

 $ git clone http://web.server/proj.git

=== Git Over Anything ===

Want to synchronize repositories without servers, or even a network connection?
Need to improvise during an emergency? We've seen <<makinghistory, *git
fast-export* và *git fast-import* có thể chuyển đổi một kho chứa thành một tệp tin đơn
và ngược lại>>. We could shuttle such files back and forth to transport git
repositories over any medium, nhưng có một công cụ hiệu quả hơn đó chính là *git bundle*.

The sender creates a 'bundle':

 $ git bundle create somefile HEAD

then transports the bundle, +somefile+, to the other party somehow: thư điện tử,
ổ đĩa USB, an *xxd* printout and an OCR scanner, reading bits over the phone,
smoke signals, v.v.. The receiver retrieves commits from the bundle by typing:

 $ git pull somefile

The receiver can even do this from an empty repository. Despite its
size, +somefile+ contains the entire original git repository.

In larger projects, eliminate waste by bundling only changes the other
repository lacks. For example, suppose the commit ``1b6d...'' is the most
recent commit shared by both parties:

 $ git bundle create somefile HEAD ^1b6d

If done frequently, one could easily forget which commit was last sent. The
help page suggests using tags to solve this. Namely, after you send a bundle,
type:

 $ git tag -f lastbundle HEAD

and create new refresher bundles with:

 $ git bundle create newbundle HEAD ^lastbundle

=== Patches: The Global Currency ===

Patches are text representations of your changes that can be easily understood
by computers and humans alike. This gives them universal appeal. You can email a
patch to developers no matter what version control system they're using. As long
as your audience can read their email, they can see your edits. Similarly, on
your side, all you require is an email account: there's no need to setup an online Git repository.

Recall from the first chapter:

 $ git diff 1b6d > my.patch

outputs a patch which can be pasted into an email for discussion. In a Git
repository, type:

 $ git apply < my.patch

to apply the patch.

In more formal settings, when author names and perhaps signatures should be
recorded, generate the corresponding patches past a certain point by typing:

 $ git format-patch 1b6d

The resulting files can be given to *git-send-email*, or sent by hand. You can also specify a range of commits:

 $ git format-patch 1b6d..HEAD^^

On the receiving end, save an email to a file, then type:

 $ git am < email.txt

This applies the incoming patch and also creates a commit, including information such as the author.

With a browser email client, you may need to click a button to see the email in its raw original form before saving the patch to a file.

There are slight differences for mbox-based email clients, but if you use one
of these, you're probably the sort of person who can figure them out easily
without reading tutorials!

=== Rất tiếc! Tôi đã chuyển đi ===

Sau khi nhân bản kho chứa, việc chạy lệnh *git push* hay *git pull* sẽ tự động
push tới hay pull từ URL gốc. Git đã làm điều này như thế nào? Bí mật nằm ở chỗ
các tùy chọn config đã được tạo ra cùng với bản sao. Hãy xem thử:

 $ git config --list

Tùy chọn +remote.origin.url+ sẽ lưu giữ URL; ``origin'' là cái tên
được đặt cho kho nguồn. As with the ``master'' branch convention, chúng ta có thể
thay đổi hay xóa các tên này nhưng chẳng có lý do gì để phải làm như thế cả.

Nếu kho chứa nguyên bản đã chuyển chỗ, chúng ta có thể cập nhật URL thông qua:

 $ git config remote.origin.url git://new.url/proj.git

The +branch.master.merge+ option specifies the default remote branch in
a *git pull*. During the initial clone, it is set to the current branch of the
source repository, so even if the HEAD of the source repository subsequently
moves to a different branch, a later pull will faithfully follow the
original branch.

This option only applies to the repository we first cloned from, which is
recorded in the option +branch.master.remote+. If we pull in from other
repositories we must explicitly state which branch we want:

 $ git pull git://example.com/other.git master

The above explains why some of our earlier push and pull examples had no
arguments.

=== Remote Branches ===

Khi bạn nhân bản một kho chứa, bạn cũng đồng thời nhân bản tất cả các nhánh của nó. You may not have
noticed this because Git hides them away: you must ask for them specifically.
This prevents branches in the remote repository from interfering with
your branches, và cũng làm cho Git dễ dàng hơn với người mới dùng.

Ta liệt kê các nhánh bằng lệnh:

 $ git branch -r

Bạn nhận được kết quả trông giống như thế này:

 origin/HEAD
 origin/master
 origin/experimental

These represent branches and the HEAD of the remote repository, and can be used
trong các lệnh Git thông thường. Ví dụ như là, suppose you have made many commits, and
wish to compare against the last fetched version. You could search through the
logs for the appropriate SHA1 hash, but it's much easier to type:

 $ git diff origin/HEAD

Or you can see what the ``experimental'' branch has been up to:

 $ git log origin/experimental

=== Multiple Remotes ===

Giả sử hai người cùng phát triển trên một sự án của chúng ta, và họ muốn
keep tabs on both. Chúng ta theo dõi hơn một kho chứa tại một thời điểm với lệnh:

 $ git remote add other git://example.com/some_repo.git
 $ git pull other some_branch

Bây giờ chúng ta có thể trộn in a branch from the second repository, and we have
easy access to all branches of all repositories:

 $ git diff origin/experimental^ other/some_branch~5

But what if we just want to compare their changes without affecting our own
work? Nói cách khác, we want to examine their branches without having
their changes invade our working directory. Then rather than pull, run:

 $ git fetch        # Fetch from origin, the default.
 $ git fetch other  # Fetch from the second programmer.

This just fetches histories. Although the working directory remains untouched,
we can refer to any branch of any repository in a Git command because we now
possess a local copy.

Recall that behind the scenes, lệnh pull đơn giản là *fetch* sau đó *merge*.
Thông thường chúng ta *pull* bởi vì chúng ta muốn trộn với lần commit cuối cùng sau khi fetch;
việc làm này this situation is a notable exception.

Xem *git help remote* for how to remove remote repositories, ignore certain
branches, và những thứ khác nữa.

=== My Preferences ===

Với dự án của mình, tôi thích những người cộng tác tạo các kho chứa ở nơi mà tôi có thể
pull. Some Git hosting services let you host your own fork of a project with
chỉ cần sử dụng chuột.

After I fetch a tree, I run Git commands to navigate and examine the changes,
which ideally are well-organized and well-described. I merge my own changes,
and perhaps make further edits. Once satisfied, I push to the main repository.

Mặc dù tôi ít nhận được sự cộng tác, nhưng tôi tin rằng việc này sẽ thay đổi theo chiều hướng
tốt lên. Hãy đọc
http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html[blog của Linus Torvalds].

Staying in the Git world is slightly more convenient than patch files, as it
saves me from converting them to Git commits. Hơn thế nữa, Git giữ các thông tin rất chi tiết
như là ghi lại tên và địa chỉ thư điện tử của tác giả, cũng như là ngày tháng và
thời gian, và nó cũng đòi hỏi tác giả phải mô tả về những thay đổi của họ.
