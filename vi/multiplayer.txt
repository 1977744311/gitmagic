== Multiplayer Git ==

Lúc đầu tôi sử dụng Git cho dự án riêng mà tôi là người duy nhất phát triển nó.
Trong số những lệnh liên quan đến bản chất phân tán của Git, tôi chỉ cần lệnh *pull*
và *clone* để giữ cùng một dự án nhưng ở những chỗ khác nhau.

Sau đó tôi muốn mã nguồn của mình được phổ biến trên mạng bằng việc sử dụng Git, và bao gồm cả những thay đổi từ
những người đóng góp. Tôi đã phải học cách làm thế nào để quản lý các dự án có nhiều người phát triển phần mềm
ở khắp nơi trên toàn thế giới. May mắn thay, đây là sở trường của Git, và người ta có thể nói đây là
điều sống còn của một hệ thống quản lý mã nguồn.


=== Tôi Là Ai? ===

Mỗi lần commit sẽ lưu giữ tên và địa chỉ thư điện tử, điều này có thể nhìn thấy bằng lệnh *git log*.
Theo mặc định, Git sử dụng các trường để lưu giữ các cài đặt trong hệ thống của mình.
Để chỉ định chúng một cách rõ ràng, hãy gõ:

  $ git config --global user.name "John Doe"
  $ git config --global user.email johndoe@example.com

Bỏ qua cờ global để đặt những thông tin này chỉ sử dụng cho kho chứa hiện tại.

=== Git Thông Qua SSH, HTTP ===

Giả sử bạn có thể truy cập vào một máy chủ web qua SSH, nhưng Git lại chưa được cài đặt ở đây. Mặc dù
không hiệu quả như giao thức nguyên bản của nó, nhưng Git vẫn có thể truyền thông thông qua HTTP.

Tải về, dịch và cài Git bằng tài khoản của bạn, và tạo kho chứa tại
thư mục chứa trang web của bạn:

 $ GIT_DIR=proj.git git init
 $ cd proj.git
 $ git --bare update-server-info
 $ cp hooks/post-update.sample hooks/post-update

Với các phiên bản Git cũ, lệnh copy không thực hiện được và bạn phải chạy:

 $ chmod a+x hooks/post-update

Từ giờ bạn có thể xuất bản mới nhất của mình thông qua SSH từ một bản sao bất kỳ:

 $ git push web.server:/path/to/proj.git master

và mọi người có thể lấy dự án của bạn với lệnh:

 $ git clone http://web.server/proj.git

=== Git Thông Qua Mọi Thứ ===

Want to synchronize repositories without servers, or even a network connection?
Need to improvise during an emergency? We've seen <<makinghistory, *git
fast-export* và *git fast-import* có thể chuyển đổi một kho chứa thành một tệp tin đơn
và ngược lại>>. We could shuttle such files back and forth to transport git
repositories over any medium, nhưng có một công cụ hiệu quả hơn đó chính là *git bundle*.

The sender creates a 'bundle':

 $ git bundle create somefile HEAD

then transports the bundle, +somefile+, to the other party somehow: thư điện tử,
ổ đĩa USB, và *xxd* printout and an OCR scanner, reading bits over the phone,
smoke signals, v.v.. The receiver retrieves commits from the bundle by typing:

 $ git pull somefile

The receiver can even do this from an empty repository. Despite its
size, +somefile+ contains the entire original git repository.

In larger projects, eliminate waste by bundling only changes the other
repository lacks. For example, suppose the commit ``1b6d...'' is the most
recent commit shared by both parties:

 $ git bundle create somefile HEAD ^1b6d

If done frequently, one could easily forget which commit was last sent. The
help page suggests using tags to solve this. Namely, after you send a bundle,
type:

 $ git tag -f lastbundle HEAD

and create new refresher bundles with:

 $ git bundle create newbundle HEAD ^lastbundle

=== Patches: The Global Currency ===

Patches are text representations of your changes that can be easily understood
by computers and humans alike. This gives them universal appeal. Bạn có thể gửi miếng vá qua
thư điện tử cho những nhà phát triển phần mềm khác mà chẳng cần lo họ đang sử dụng hệ thống mã nguồn nào. As long
as your audience can read their email, they can see your edits. Tương tự thế, về phía mình,
những thứ bạn cần là có một địa chỉ thư điện tử: ở đây chẳng cần cài đặt kho chứa Git trên mạng.

Recall from the first chapter:

 $ git diff 1b6d > my.patch

outputs a patch which can be pasted into an email for discussion. Ở kho Git,
gõ:

 $ git apply < my.patch

để áp dụng miếng vá.

In more formal settings, when author names and perhaps signatures should be
recorded, generate the corresponding patches past a certain point by typing:

 $ git format-patch 1b6d

The resulting files can be given to *git-send-email*, hay có thể gửi thủ công. Bạn cũng có thể chỉ định rõ một vùng commit:

 $ git format-patch 1b6d..HEAD^^

On the receiving end, save an email to a file, then type:

 $ git am < email.txt

This applies the incoming patch and also creates a commit, bao gồm các thông tin như là tác giả.

Với một chương trình đọc thư điện tử, bạn có thể sử dụng con chuột để to see the email in its raw original form trước khi ghi miếng vá thành một tệp tin.

There are slight differences for mbox-based email clients, nhưng nếu bạn sử dụng một trong
số chúng, you're probably the sort of person who can figure them out easily
without reading tutorials!

=== Rất tiếc! Tôi đã chuyển đi ===

Sau khi nhân bản kho chứa, việc chạy lệnh *git push* hay *git pull* sẽ tự động
push tới hay pull từ URL gốc. Git đã làm điều này như thế nào? Bí mật nằm ở chỗ
các tùy chọn config đã được tạo ra cùng với bản sao. Hãy xem thử:

 $ git config --list

Tùy chọn +remote.origin.url+ sẽ lưu giữ URL; ``origin'' là cái tên
được đặt cho kho nguồn. As with the ``master'' branch convention, chúng ta có thể
thay đổi hay xóa các tên này nhưng chẳng có lý do gì để phải làm như thế cả.

Nếu kho chứa nguyên bản đã chuyển chỗ, chúng ta có thể cập nhật URL thông qua:

 $ git config remote.origin.url git://new.url/proj.git

The +branch.master.merge+ option specifies the default remote branch in
a *git pull*. During the initial clone, it is set to the current branch of the
source repository, so even if the HEAD of the source repository subsequently
moves to a different branch, a later pull will faithfully follow the
original branch.

This option only applies to the repository we first cloned from, which is
recorded in the option +branch.master.remote+. If we pull in from other
repositories we must explicitly state which branch we want:

 $ git pull git://example.com/other.git master

Phần phía trên giải thích tại sao một số lệnh push và pull ví dụ của chúng ta lại không có
tham số.

=== Remote Branches ===

Khi bạn nhân bản một kho chứa, bạn cũng đồng thời nhân bản tất cả các nhánh của nó. You may not have
noticed this because Git hides them away: you must ask for them specifically.
This prevents branches in the remote repository from interfering with
your branches, và cũng làm cho Git dễ dàng hơn với người mới dùng.

Ta liệt kê các nhánh bằng lệnh:

 $ git branch -r

Bạn nhận được kết quả trông giống như thế này:

 origin/HEAD
 origin/master
 origin/experimental

These represent branches and the HEAD of the remote repository, and can be used
trong các lệnh Git thông thường. Ví dụ như là, suppose you have made many commits, and
wish to compare against the last fetched version. You could search through the
logs for the appropriate SHA1 hash, but it's much easier to type:

 $ git diff origin/HEAD

Or you can see what the ``experimental'' branch has been up to:

 $ git log origin/experimental

=== Multiple Remotes ===

Giả sử hai người cùng phát triển trên một sự án của chúng ta, và họ muốn
keep tabs on both. Chúng ta theo dõi hơn một kho chứa tại một thời điểm với lệnh:

 $ git remote add other git://example.com/some_repo.git
 $ git pull other some_branch

Bây giờ chúng ta có thể trộn với nhánh của kho chứa thứ hai, and we have
easy access to all branches of all repositories:

 $ git diff origin/experimental^ other/some_branch~5

But what if we just want to compare their changes without affecting our own
work? Nói cách khác, we want to examine their branches without having
their changes invade our working directory. Thế thì thay vì pull, hãy chạy:

 $ git fetch        # Fetch from origin, the default.
 $ git fetch other  # Fetch from the second programmer.

This just fetches histories. Although the working directory remains untouched,
we can refer to any branch of any repository in a Git command because we now
possess a local copy.

Recall that behind the scenes, lệnh pull đơn giản là *fetch* sau đó *merge*.
Thông thường chúng ta *pull* bởi vì chúng ta muốn trộn với lần commit cuối cùng sau khi fetch;
việc làm này this situation is a notable exception.

Xem *git help remote* để biết cách làm thế nào để gỡ bỏ kho chứa trên mạng, bỏ qua certain
branches, và những thứ khác nữa.

=== Sở Thích Riêng Của Tôi ===

Với dự án của mình, tôi thích những người cộng tác tạo các kho chứa ở nơi mà tôi có thể
pull. Một số dịch vụ Git cho phép bạn host your own fork of a project with
chỉ cần sử dụng chuột.

Sau khi tôi fetch a tree, I run Git commands to navigate và xem xét các thay đổi,
which ideally are well-organized and well-described. I merge my own changes,
và có thể sẽ sửa thêm chút nữa. Khi đã hài lòng, tôi push tới kho chứa chính.

Mặc dù tôi ít nhận được sự cộng tác, nhưng tôi tin rằng việc này sẽ thay đổi theo chiều hướng
tốt lên. Hãy đọc
http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html[blog của Linus Torvalds].

Trong thế giới Git world is slightly more convenient than patch files, as it
saves me from converting them to Git commits. Hơn thế nữa, Git giữ các thông tin rất chi tiết
như là ghi lại tên và địa chỉ thư điện tử của tác giả, cũng như là ngày tháng và
thời gian, và nó cũng đòi hỏi tác giả phải mô tả về những thay đổi của họ.
