== Lessons of History ==

A consequence of Git's distributed nature is that history can be edited
easily. Nhưng nếu bạn xáo trộn quá khứ, hãy cẩn thận: only rewrite that part of
history which you alone possess. Just as nations forever argue over who
committed what atrocity, if someone else has a clone whose version of history
differs to yours, you will have trouble reconciling when your trees interact.

Một số nhà phát triển phần mềm quả quyết rằng lịch sử có thể be immutable, warts and all.
Others feel trees should be made presentable before they are unleashed in
public. Git chấp nhận cả hai quan điểm. Giống như việc nhân bản, tạo nhánh và hòa trộn,
viết lại lịch sử đơn giản chỉ là một quyền mà Git trao cho bạn. It is up to you
to use it wisely.

=== Dừng Lại Sửa Chữa ===

Bạn vừa mới commit, nhưng lại ước mình đã gõ những dòng chú thích có nội dung khác phải không? Thế thì hãy chạy:

 $ git commit --amend

để thay đổi chú thích cuối cùng. Bạn giật mình vì quên thêm các tệp tin vào? Chạy lệnh *git add* để
thêm nó vào, và sau đó lại chạy lệnh ở trên.

Bạn muốn thêm vài chỉnh sửa vào lần cuối mình đã commit ư? Thế thì cứ sửa chúng đi và sau đó chạy lệnh:

 $ git commit --amend -a

=== ... And Then Some ===

Let's suppose the previous problem is ten times worse. After a lengthy session you've made a bunch of commits. Nhưng bạn không hoàn toàn hài lòng với cách mà chúng được tổ chức, và một số lần commit cần được soạn lại phần mô tả. Thế thì hãy gõ:

 $ git rebase -i HEAD~10

và 10 commit cuối sẽ xuất hiện trong $EDITOR yêu thích của bạn. Dưới đây là một đoạn trích ví dụ:

    pick 5c6eb73 Added repo.or.cz link
    pick a311a64 Reordered analogies in "Work How You Want"
    pick 100834f Added push target to Makefile

Thế thì:

- Xóa bỏ các lần commit bằng cách xóa các dòng tương ứng.
-Đặt lại các lần commit bằng các đặt lại các dòng.
- Thay thế `pick` với:
   * `edit` để đánh dấu lần commit đó là dành cho việc tu bổ.
   * `reword` để thay đổi phần chú giải.
   * `squash` để hòa trộn với lần commit trước.
   * `fixup` để hòa trộn với lần commit trướcvà bỏ qua việc ghi lại phần chú giải.

Ghi lại và thoát ra. Nếu bạn đánh dấu một lần commit dành cho việc sửa đổi, thế thì
chạy:

 $ git commit --amend

Cách khác, chạy:

 $ git rebase --continue

Do vậy cứ commit thoải mái và thường xuyên bởi vì bạn có thể dọn dẹp cho gọn gàng sau bằng lệnh rebase.

=== Local Changes Last ===

You're working on an active project. You make some local commits over time, and
then you sync with the official tree with a merge. This cycle repeats itself a few times before you're ready to push to the central tree.

But now the history in your local Git clone is a messy jumble of your changes and the official changes. You'd prefer to see all your changes in one contiguous section, and after all the official changes.

Đây chính là công việc dành cho lệnh *git rebase* đã được miêu tả ở trên. Trong nhiều trường hợp bạn có thể sử dụng
cờ *--onto* và and avoid interaction.

Xem thêm trong *git help rebase* để thấy được chi tiết các ví dụ dành cho lệnh đáng kinh ngạc này. Bạn có thể chia cắt các lần  commit. Bạn còn có thể xắp xếp lại các nhánh của một cấu trúc cây.

=== Viết Lại Lịch Sử ===

Occasionally, bạn muốn việc quản lý mã nguồn giống việc người ta vẽ quivalent of airbrushing people out
of official photos, erasing them from history in a Stalinesque fashion. Ví
dụ, giả sử chúng ta có ý định phát hành dự án, nhưng lại dibut it involves a file that
phải được giữ bí mật vì lý do nào đó. Có lẽ tôi đã quên khi ghi lại số thẻ tín dụng vào trong một tệp tin
văn bản và ngẫu nhiên nó được thêm vào trong dự án. Việc xóa tệp tin này là
chưa đủ, bởi vì ta có thể đọc nó từ lần commit cũ. Chúng ta phải gỡ bỏ
tệp tin này từ tất cả các lần đã commit:

 $ git filter-branch --tree-filter 'rm top/secret/file' HEAD

Xem *git help filter-branch*, nội dung của nó sẽ thảo luận về ví dụ này và đưa ra
một cách thức nhanh hơn. Đại thể, lệnh *filter-branch* lets you alter large sections of history
chỉ bằng một lệnh đơn.

Afterwards, the +.git/refs/original+ directory describes the state of affairs before the operation. Check the filter-branch command did what you wanted, then delete this directory if you wish to run more filter-branch commands.

Cuối cùng, thay thế bản sao của dự án của bạn bằng phiên bản bạn đã sửa lại nếu bạn muốn to interact with them later.

=== Tự Tạo Lịch Sử ===

[[makinghistory]]
Bạn muốn chuyển đổi dự án của mình sang sử dụng Git? If it's managed with one of the more well-known systems, then chances are someone has already written a script to export the whole history to Git.

Nếu không, thì xét đến lệnh *git fast-import*, lệnh này đọc văn bản đầu vào ở một định dạng
đặc thù để mà tạo ra một lịch sử cho Git từ ban đầu. Thông thường một script using this
command is hastily cobbled together and run once, migrating the project in a
single shot.

Dưới đây là một ví dụ, dán danh sách theo sau đâu vào một tệp tin tạm thời nào đó, chẳng hạn như là `/tmp/history`:
----------------------------------
commit refs/heads/master
committer Alice <alice@example.com> Thu, 01 Jan 1970 00:00:00 +0000
data <<EOT
Initial commit.
EOT

M 100644 inline hello.c
data <<EOT
#include <stdio.h>

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT


commit refs/heads/master
committer Bob <bob@example.com> Tue, 14 Mar 2000 01:59:26 -0800
data <<EOT
Replace printf() with write().
EOT

M 100644 inline hello.c
data <<EOT
#include <unistd.h>

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT

----------------------------------

Thế thì tạo một kho Git từ thư mục chứa các tệp tin tạm thời này bằng cách gõ:

 $ mkdir project; cd project; git init
 $ git fast-import --date-format=rfc2822 < /tmp/history

Bạn có thể checkout phiên bản cuối của dự án với:

 $ git checkout master .

Lệnh *git fast-export* chuyển đổi bất kỳ một kho chứa nào thành định dạng
phù hợp với lệnh *git fast-import*, whose output you can study for writing exporters,
and also to transport repositories in a human-readable format. Indeed,
these commands can send repositories of text files over text-only channels.

=== Where Did It All Go Wrong? ===

You've just discovered a broken feature in your program which you know for sure was working a few months ago. Argh! Where did this bug come from? If only you had been testing the feature as you developed.

It's too late for that now. However, provided you've been committing often, Git
can pinpoint the problem:

 $ git bisect start
 $ git bisect bad HEAD
 $ git bisect good 1b6d

Git checks out a state halfway in between. Test the feature, and if it's still broken:

 $ git bisect bad

Nếu không, thay "bad" bằng "good". Git again transports you to a state halfway
between the known good and bad versions, narrowing down the possibilities.
After a few iterations, this binary search will lead you to the commit that
caused the trouble. Một khi bạn đã hoàn tất việc điều tra, trở lại trạng thái nguyên bản
của bạn bàng cách gõ:

 $ git bisect reset

Thay vì thử nghiệm mọi thay đổi một cách thủ công, hãy tự động hóa sự tìm kiếm này bằng cách chạy:

 $ git bisect run my_script

Git uses the return value of the given command, typically a one-off script, to
decide whether a change is good or bad: the command should exit with code 0
when good, 125 when the change should be skipped, and anything else between 1
and 127 if it is bad. A negative return value aborts the bisect.

You can do much more: the help page explains how to visualize bisects, examine
or replay the bisect log, and eliminate known innocent changes for a speedier
search.

=== Who Made It All Go Wrong? ===

Giống như các hệ thống quản lý mã nguồn khác, Git cũng có lệnh blame:

 $ git blame bug.c

lệnh này chú thích tất cả các dòng có trong tệp tin được chỉ ra cho thấy ai là người cuối cùng sửa nó, và là khi nào. Không giống các hệ thống quản lý mã nguồn khác, hành động này hoạt động không cần có mạng, việc đọc chỉ đơn thuần từ ổ đĩa của máy cá nhân.

=== Kinh Nghiệm Riêng ===

Trong một hệ thống quản lý mã nguồn tập trung, thay đổi lịch sử là một việc làm
khó khăn, và chỉ thi hành được nếu là người quản trị. Việc nhân bản, tạo nhánh và
trộn không thể thiếu việc truyền thông qua mạng. Cũng như thế với các tác vụ cơ bản khác
như là duyệt lịch sử, hay là commit một thay đổi. Trong một số hệ thống khác, người dùng
yêu cầu có kết nối mạng chỉ để xem các thay đổi của họ hay mở một tệp tin
để biên tập.

Hệ thống tập trung không cho phép làm việc mà không có mạng, và đòi hỏi cơ sở hạ tầng mạng máy tính
đắt đỏ tốn kém, đặc biệt là khi số nhà phát triển phần mềm tăng lên. Điều quan trọng,
all operations are slower to some degree, thườn thường to the point
where users shun advanced commands unless absolutely necessary. Trong những trường hợp
đặc biệt cases this is true of even the most basic commands. Khi những người dùng phải chạy
các lệnh chạy chậm, hiệu suất bị giảm bởi vì nó làm gián đoạn công việc của cả một dây truyền.

I experienced these phenomena first-hand. Git là hệ thống quản lý mã nguồn
đầu tiên tôi sử dụng. I quickly grew accustomed to it, taking many features for
granted. I simply assumed other systems were similar: việc chọn lựa một hệ thống
quản lý mã nguồn ought to be no different from choosing a text editor hay trình
duyệt web.

Tôi sẽ sốc nếu như sau này bị bắt buộc sử dụng hệ thống quản lý mã nguồn tập trung. A flaky internet
connection matters little with Git, but makes development unbearable when it
needs to be as reliable as local disk. Thêm nữa, I found myself conditioned
to avoid certain commands because of the latencies involved, which ultimately
prevented me from following my desired work flow.

Khi tôi phải chạy những lệnh chậm chạp, việc làm ngắt quãng việc suy nghĩ
dealt a disproportionate amount of damage. Trong khi chờ cho việc truyền thông
với máy chủ hoàn tất, tôi sẽ phải làm một vài thứ gì đó khác để lấp chỗ trống, chẳng hạn như
lấy thư điện tử hay viết tài liệu. Sau một khoảng thời gian tôi quay trở lại nhiệm vụ
chính của mình, lệnh đã hoàn tất từ lâu rồi, và tôi phải lãng phí thêm nhiều thời gian nữa
để nhớ lại xem mình đang làm gì. Con người thường dở khi phải thay đổi mạch văn.

There was also an interesting tragedy-of-the-commons effect: anticipating
network congestion, nhiều cá nhân riêng lẻ có thể chiếm dụng nhiều lưu lượng mạng hơn cần thiết
trên các tác vụ khác nhau in an attempt to reduce future delays. Hệ quả cuối cùng
sự quá tải quá mức, việc ủng hộ việc tiêu dùng cá nhân s to consume even more bandwidth
next time to avoid even longer delays.
