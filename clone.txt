= Cloning Around =

In older version control systems, checkout was the standard way to get a saved state. You'd checkout a bunch of files in the requested saved state.

In Git and other distributed version control systems, the standard way to get files is to create a clone of the entire repository. In other words, you practically create a mirror of the central repository. So anything the central repository can do, you can do.

== Sync Computers ==

This is the reason I first used Git. I can tolerate making tarballs or using <tt>rsync</tt> for backups and basic syncing. The problem was sometimes I'd edit on my laptop, other times on my desktop, and they may not have talked to each other in between.

Initialize a Git repository and commit your files as above on one machine. Then on the other:

 $ git-clone other.computer:/path/to/files

to create a second copy of the files and Git respository. From now on,

 $ git-commit -a
 $ git-pull other.computer:/path/to/files

will pull in the state of the files on the other computer into the one you're working on. If you've recently made conflicting edits in the same file, Git will let you know and you should commit again after resolving them.

If you have not committed any changes on the other computer, you may type

 $ git-push other.computer:/path/to/files

to push the current state to the other computer. Next time you're logged in to the other computer, run

 $ git-checkout HEAD .

to update the files before working on them. Be aware that you'll lose any uncommitted changes when you do this.

== Classic Source Control ==

Initialize a Git repository for your files: 

 $ git-init-db
 $ git add .
 $ git commit -m "Initial commit"

On the central server, initialize an empty Git repository with some name:

 $ GIT_DIR=proj.git git-init-db

Some public hosts, such as [[http://repo.or.cz][repo.or.cz]], will have a different method for setting up the initially empty Git repository, such as filling in a form on a webpage.

Push your project to the central server with:

 $ git-push git://central.server/path/to/proj.git HEAD

We're ready. To check out source, a developer types

 $ git clone central.server:/path/to/proj.git

After making changes, the code is checked in to the main server by:

 $ git commit -a
 $ git push

If the main server has been updated, the latest version needs to be checked out before the push. To sync to the latest version:

 $ git commit -a
 $ git pull

A popular misconception is that Git is ill-suited for projects requiring an official central repository (see for example [[http://www.subversionary.org/martintomes/git][this blog post]]). Nothing could be further from the truth. Photographing someone does not cause their soul to be stolen. Similarly, cloning the master repository does not make its importance diminish.

A good first approximation is that anything a centralized version control system can do, Git can do better. While not strictly true, one is less likely to make erroneous comparisons with this rule of thumb.

You might not use most of Git's features in a small project, but there is nothing wrong with this as there is negligible overhead. And who knows, perhaps your project will grow beyond your original expectations. It's like using a Swiss army knife to mostly open bottles. On the day you desperately need a screwdriver you'll be glad you have it with you.

== Forking a Project ==

Sick of the way a project is being run? Think you could do a better job? Then on your server:

 $ git clone main.server:/path/to/files

Next tell everyone to check out your fork of the project at your server.

At any later time, you can merge in the changes from the original project with:

 $ git pull

== Ultimate Backups ==

Want numerous tamper-proof geographically diverse redundant archives? If your project has many developers, don't do anything! Everyone who clones your code is effectively a backup, not just of the current state of the project, but of your project's entire history. Thanks to cryptographic hashing, if someone's clone become corrupted, it will be spotted as soon as they try to communicate with others.

If your project is not so popular, find as many hosts as you can and clone your project there.

The truly paranoid should always write down the latest 20-byte SHA1 hash of the HEAD somewhere safe. It has to be safe, not private. For example, publishing it in a newspaper would work well, because it's hard for an attacker to alter every copy of a newspaper.

== Light-Speed Multitask ==

Say you want to work on several features in parallel. Then after committing your project:

 $ git-clone --local --shared . /some/new/directory

The options can be written as <tt>-l -s</tt> instead, which I like to think of as an acronym for "Light Speed"!

Git exploits hard links and file sharing as much as possible to create this clone. Subsequently, this clone is unsuitable as a backup. However, it's ready in a flash, and you can now work on two independent features simultaneously. For example, you can edit one clone while the other is compiling.

At any time, you can commit and pull changes from one to the other.

 $ git-pull one /to/the/other

== Guerilla Version Control ==

Are you working on a project that uses some other version control system, and you sorely miss Git? Then initialize a Git repository in your working directory:

 $ git-init-db
 $ git add .
 $ git commit -m "Initial commit"

then clone it:

 $ git-clone -l -s  . /some/new/directory

Now go to the new directory and work here instead, using Git to your heart's content. Once in a while, you'll want to sync with everyone else, in which case go to the original directory, sync using the other version control system, and type:

 $ git add .
 $ git commit -m "sync with everyone else"

Then go to the new directory and run:

 $ git commit -a -m "description of my changes"
 $ git pull

On the other hand, the procedure for giving your changes to everyone else varies depending on the other version control system. You have the files you want to push in the new directory, and running a few commands of the other version control system will upload them to the central repository.
