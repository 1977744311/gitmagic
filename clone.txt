= Cloning Around =

In older version control systems, checkout was the standard way to get a saved state. On checkout, you'd get a bunch of files in the requested saved state.

In Git, the standard way to get files is to create a clone of the entire repository. In other words, you practically create a mirror of the central repository, so you can do anything the central repostiory can do.

== Sync Computers ==

This is the reason I first used Git. I can tolerate making tarballs or using <tt>rsync</tt> for backups. The problem was sometimes I'd edit on my laptop, other times on my desktop, and they may not have talked to each other in between.

Initialize a Git repository and commit your files as above on one machine. Then on the other:

 $ git-clone other.computer:/path/to/files

to create a second copy of the files and Git respository. From now on,

 $ git-commit -a
 $ git-pull other.computer:/path/to/files

will pull in the state of the files on the other computer into the one you're working on. If you've recently made conflicting edits in the same file, Git will let you know and you should commit again after resolving them.

If you have not committed any changes on the other computer, you may type

 $ git-push other.computer:/path/to/files

to push the current state to the other computer. Next time you're logged in to the other computer, run

 $ git-checkout HEAD .

to update the files before working on them. Be aware that you'll lose any uncommitted changes after.

== Classic Source Control ==

Copy your project to a directory in your main server. Initialize a Git
repository: <tt>git init ; git add . ; git commit -m "Initial commit"</tt>.

To check out source, a developer types

 $ git clone main.server:/path/to/files

After making changes, the code is checked in to the main server by:

 $ git commit -a
 $ git push

If the main server has been updated, the latest version needs to be checked out before the push. To sync to the latest version:

 $ git commit -a
 $ git pull

== Forking a Project ==

Sick of the way a project is being run? Think you could do a better job?

First, on your server:

 $ git clone main.server:/path/to/files

Then tell everyone to check out your fork of the project at your server.

At any later time, you can merge in the changes from the original project with:

 $ git pull

== Ultimate Backups ==

How would you like multiple tamper-proof geographically diverse redundant archives?

TODO

== Guerilla Version Control ==

TODO

== Working On Features In Parallel ==

TODO

== Source Control Engine Tools and Utilities ==

TODO
